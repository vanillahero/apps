<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Nine Men's Morris Mobile</title>
<style>
:root {
--bg-color: #121212;
--surface-color: #1e1e1e;
--primary-color: #bb86fc;
--secondary-color: #03dac6;
--text-color: #e0e0e0;
--board-line: #555;
--p1-color: #03dac6;
--p2-color: #cf6679;
--log-bg: #111;
}
body {
margin: 0;
padding: 0;
width: 100vw;
height: 100vh;
background-color: var(--bg-color);
color: var(--text-color);
font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
overflow: hidden;
}
#game-container {
width: 100%;
height: 100%;
background-color: var(--surface-color);
display: flex;
flex-direction: column;
}
#ui-panel {
flex: 0 0 auto;
padding: 20px;
display: flex;
flex-direction: column;
border-top: 1px solid #333;
gap: 15px;
background-color: var(--bg-color);
}
#main-view {
flex: 1;
position: relative;
display: flex;
justify-content: center;
align-items: center;
background: radial-gradient(circle at center, #2a2a2a 0%, #1e1e1e 80%);
}
.controls-wrapper {
display: flex;
gap: 10px;
}
.control-group {
flex: 1;
}
label {
display: block;
margin-bottom: 8px;
font-weight: bold;
font-size: 0.9rem;
text-transform: uppercase;
letter-spacing: 1px;
}
select,
button {
width: 100%;
padding: 10px;
background-color: #333;
border: 1px solid #444;
color: white;
border-radius: 4px;
font-size: 1rem;
cursor: pointer;
transition: all 0.2s;
}
select:hover,
button:hover {
background-color: #444;
border-color: var(--primary-color);
}
button.primary {
background-color: var(--primary-color);
color: #000;
font-weight: bold;
border: none;
}
button.primary:hover {
background-color: #a370f7;
}
#status-display {
padding: 15px;
background-color: rgba(0, 0, 0, 0.2);
border-radius: 4px;
border-left: 4px solid var(--primary-color);
}
#turn-info {
font-size: 1.2rem;
margin-bottom: 5px;
}
#phase-info {
font-size: 0.9rem;
color: #888;
}
#info-bar {
text-align: center;
padding: 5px;
min-height: 1.2em;
border-radius: 4px;
background-color: rgba(0, 0, 0, 0.2);
opacity: 0;
transition: opacity 0.3s ease;
font-size: 0.9rem;
}
#info-bar.highlight {
color: var(--primary-color);
}
#info-bar.error {
color: var(--p2-color);
}
#board {
width: 90vw;
height: 90vw;
max-width: 60vh;
max-height: 60vh;
position: relative;
transition: opacity 0.3s;
}
.board-fade {
opacity: 0;
}
.board-line {
position: absolute;
background-color: var(--board-line);
}
.node {
width: 6vw;
height: 6vw;
max-width: 40px;
max-height: 40px;
background-color: #333;
border-radius: 50%;
position: absolute;
transform: translate(-50%, -50%);
z-index: 10;
cursor: pointer;
border: clamp(2px, 0.6vw, 4px) solid #555;
transition: all 0.2s;
box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
}
.node:hover {
border-color: #777;
transform: translate(-50%, -50%) scale(1.1);
}
.node.p1 {
background-color: var(--p1-color);
border-color: var(--p1-color);
box-shadow: 0 0 15px var(--p1-color);
}
.node.p2 {
background-color: var(--p2-color);
border-color: var(--p2-color);
box-shadow: 0 0 15px var(--p2-color);
}
.node.selected {
background-color: white;
border-color: white;
}
.node.highlight {
background-color: rgba(255, 255, 255, 0.2);
border-color: var(--secondary-color);
animation: pulse 1s infinite;
}
@keyframes pulse {
0% {
transform: translate(-50%, -50%) scale(1);
}
50% {
transform: translate(-50%, -50%) scale(1.2);
}
100% {
transform: translate(-50%, -50%) scale(1);
}
}
.node.move-target {
border-color: var(--secondary-color);
background-color: rgba(3, 218, 198, 0.15);
transform: translate(-50%, -50%) scale(1.1);
}
#message-overlay {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: rgba(0, 0, 0, 0.85);
display: flex;
justify-content: center;
align-items: center;
flex-direction: column;
z-index: 100;
display: none;
}
#message-overlay h2 {
font-size: 3rem;
margin-bottom: 20px;
color: var(--primary-color);
}
.stats-box {
display: flex;
gap: 10px;
margin-top: 10px;
}
.stat-chip {
background: #333;
padding: 5px 10px;
border-radius: 12px;
font-size: 0.8rem;
display: flex;
align-items: center;
gap: 5px;
}
.dot {
width: 8px;
height: 8px;
border-radius: 50%;
}
#turn-info.thinking {
animation: thinking-pulse 1.5s infinite;
}
@keyframes thinking-pulse {
0% {
opacity: 1;
}
50% {
opacity: 0.6;
}
100% {
opacity: 1;
}
}
#rotate-message {
display: none;
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: #000;
color: #0f0;
flex-direction: column;
justify-content: center;
align-items: center;
z-index: 100;
text-align: center;
}
#rotate-message svg {
width: 64px;
height: 64px;
fill: #0f0;
margin-bottom: 20px;
animation: rotate-to-portrait 2s infinite ease-in-out;
}
@keyframes rotate-to-portrait {
0%,
100% {
transform: rotate(90deg);
}
50% {
transform: rotate(0deg);
}
}
@media (orientation: landscape) {
#rotate-message {
display: flex;
}
}
</style>
</head>
<body>
<div id="rotate-message">
<svg viewBox="0 0 24 24">
<path d="M17,1.01L7,1C5.9,1 5,1.9 5,3v18c0,1.1 0.9,2 2,2h10c1.1,0 2,-0.9 2,-2V3C19,1.9 18.1,1.01 17,1.01z M17,21H7l0,-1h10V21z M17,18H7V6h10V18z M7,4V3h10v1H7z" />
</svg>
<p>PLEASE ROTATE DEVICE</p>
</div>
<div id="game-container">
<div id="main-view">
<div id="board">
</div>
<div id="message-overlay">
<h2 id="winner-text">You Win!</h2>
<button class="primary" style="width: 200px;" onclick="startGame()">Play Again</button>
</div>
</div>
<div id="ui-panel">
<div id="status-display">
<div id="turn-info">Player's Turn</div>
<div id="phase-info">Phase: Placing Pieces</div>
<div class="stats-box">
<div class="stat-chip">
<div class="dot" style="background:var(--p1-color)"></div><span id="p1-count">9</span>
</div>
<div class="stat-chip">
<div class="dot" style="background:var(--p2-color)"></div><span id="p2-count">9</span>
</div>
</div>
</div>
<div id="info-bar">Welcome to Nine Men's Morris!</div>
<div class="controls-wrapper">
<div class="control-group">
<select id="difficulty-select" onchange="handleDifficultyChange()">
<option value="2">Easy (Novice)</option>
<option value="4" selected>Medium (Standard)</option>
<option value="5">Hard (Master)</option>
</select>
</div>
<div class="control-group">
<button class="primary" onclick="startGame()">New Game</button>
</div>
</div>
</div>
</div>
<script>
const ADJACENCY = {
0: [1, 9],
1: [0, 2, 4],
2: [1, 14],
3: [4, 10],
4: [1, 3, 5, 7],
5: [4, 13],
6: [7, 11],
7: [4, 6, 8],
8: [7, 12],
9: [0, 10, 21],
10: [3, 9, 11, 18],
11: [6, 10, 15],
12: [8, 13, 17],
13: [5, 12, 14, 20],
14: [2, 13, 23],
15: [11, 16],
16: [15, 17, 19],
17: [12, 16],
18: [10, 19],
19: [16, 18, 20, 22],
20: [13, 19],
21: [9, 22],
22: [19, 21, 23],
23: [14, 22]
};
const MILLS = [
[0, 1, 2],
[3, 4, 5],
[6, 7, 8],
[9, 10, 11],
[12, 13, 14],
[15, 16, 17],
[18, 19, 20],
[21, 22, 23],
[0, 9, 21],
[3, 10, 18],
[6, 11, 15],
[1, 4, 7],
[16, 19, 22],
[8, 12, 17],
[5, 13, 20],
[2, 14, 23]
];
const COORDS = [{
x: 0,
y: 0
}, {
x: 50,
y: 0
}, {
x: 100,
y: 0
},
{
x: 16.66,
y: 16.66
}, {
x: 50,
y: 16.66
}, {
x: 83.33,
y: 16.66
},
{
x: 33.33,
y: 33.33
}, {
x: 50,
y: 33.33
}, {
x: 66.66,
y: 33.33
},
{
x: 0,
y: 50
}, {
x: 16.66,
y: 50
}, {
x: 33.33,
y: 50
},
{
x: 66.66,
y: 50
}, {
x: 83.33,
y: 50
}, {
x: 100,
y: 50
},
{
x: 33.33,
y: 66.66
}, {
x: 50,
y: 66.66
}, {
x: 66.66,
y: 66.66
},
{
x: 16.66,
y: 83.33
}, {
x: 50,
y: 83.33
}, {
x: 83.33,
y: 83.33
},
{
x: 0,
y: 100
}, {
x: 50,
y: 100
}, {
x: 100,
y: 100
}
];
const SoundEngine = {
ctx: null,
init: function() {
if (!this.ctx) {
this.ctx = new(window.AudioContext || window.webkitAudioContext)();
} else if (this.ctx.state === 'suspended') {
this.ctx.resume();
}
},
playTone: function(freq, type, duration, vol = 0.1) {
if (!this.ctx) return;
const osc = this.ctx.createOscillator();
const gain = this.ctx.createGain();
osc.type = type;
osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
gain.gain.setValueAtTime(vol, this.ctx.currentTime);
gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
osc.connect(gain);
gain.connect(this.ctx.destination);
osc.start();
osc.stop(this.ctx.currentTime + duration);
},
playMove: function() {
this.playTone(300, 'sine', 0.1, 0.1);
},
playCapture: function() {
this.playTone(150, 'triangle', 0.3, 0.2);
setTimeout(() => this.playTone(100, 'triangle', 0.3, 0.2), 50);
},
playWin: function() {
this.playTone(400, 'sine', 0.2);
setTimeout(() => this.playTone(500, 'sine', 0.2), 150);
setTimeout(() => this.playTone(600, 'sine', 0.4), 300);
},
playLose: function() {
this.playTone(300, 'triangle', 0.3);
setTimeout(() => this.playTone(200, 'triangle', 0.5), 200);
},
playError: function() {
this.playTone(100, 'sawtooth', 0.1, 0.05);
}
};
let gameState = {
board: Array(24).fill(0),
turn: 1,
phase: 1,
p1Hand: 9,
p2Hand: 9,
selectedNode: -1,
mustRemove: false,
gameOver: false
};
const boardEl = document.getElementById('board');
const turnInfo = document.getElementById('turn-info');
const phaseInfo = document.getElementById('phase-info');
const p1CountEl = document.getElementById('p1-count');
const p2CountEl = document.getElementById('p2-count');
const overlay = document.getElementById('message-overlay');
const winnerText = document.getElementById('winner-text');
const infoBar = document.getElementById('info-bar');
let infoTimeout;
document.body.addEventListener('click', () => SoundEngine.init(), {
once: true
});
function log(msg, type = 'normal') {
if (infoTimeout) clearTimeout(infoTimeout);
infoBar.textContent = msg;
infoBar.className = 'info-bar';
if (type === 'error') {
infoBar.classList.add('error');
} else if (type === 'highlight') {
infoBar.classList.add('highlight');
}
infoBar.style.opacity = 1;
const shouldPersist = type === 'error' || msg.includes('Remove');
if (!shouldPersist) {
infoTimeout = setTimeout(() => {
infoBar.style.opacity = 0;
}, 2500);
}
}
function handleDifficultyChange() {
const sel = document.getElementById('difficulty-select');
const text = sel.options[sel.selectedIndex].text;
log(`Difficulty changed to: ${text}`, 'highlight');
SoundEngine.playMove();
}
function renderStaticBoard() {
boardEl.innerHTML = '';
const lines = [{
l: 0,
t: 0,
w: 100,
h: 0.5
},
{
l: 0,
t: 100,
w: 100,
h: 0.5
},
{
l: 0,
t: 0,
w: 0.5,
h: 100
},
{
l: 100,
t: 0,
w: 0.5,
h: 100
},
{
l: 16.66,
t: 16.66,
w: 66.66,
h: 0.5
},
{
l: 16.66,
t: 83.33,
w: 66.66,
h: 0.5
},
{
l: 16.66,
t: 16.66,
w: 0.5,
h: 66.66
},
{
l: 83.33,
t: 16.66,
w: 0.5,
h: 66.66
},
{
l: 33.33,
t: 33.33,
w: 33.33,
h: 0.5
},
{
l: 33.33,
t: 66.66,
w: 33.33,
h: 0.5
},
{
l: 33.33,
t: 33.33,
w: 0.5,
h: 33.33
},
{
l: 66.66,
t: 33.33,
w: 0.5,
h: 33.33
},
{
l: 50,
t: 0,
w: 0.5,
h: 33.33
},
{
l: 50,
t: 66.66,
w: 0.5,
h: 33.33
},
{
l: 0,
t: 50,
w: 33.33,
h: 0.5
},
{
l: 66.66,
t: 50,
w: 33.33,
h: 0.5
}
];
lines.forEach(l => {
const div = document.createElement('div');
div.className = 'board-line';
div.style.left = l.l + '%';
div.style.top = l.t + '%';
div.style.width = l.w ? l.w + '%' : '0.5%';
div.style.height = l.h ? l.h + '%' : '0.5%';
boardEl.appendChild(div);
});
for (let i = 0; i < 24; i++) {
const node = document.createElement('div');
node.className = 'node';
node.id = 'node-' + i;
node.style.left = COORDS[i].x + '%';
node.style.top = COORDS[i].y + '%';
node.onclick = () => handleInput(i);
boardEl.appendChild(node);
}
}
function updateView() {
let validMoveTargets = [];
if (gameState.phase === 2 && gameState.selectedNode !== -1 && !gameState.mustRemove) {
const playerPieceCount = countPieces(gameState.turn, gameState.board);
if (playerPieceCount === 3 && gameState.p1Hand === 0 && gameState.p2Hand === 0) {
for (let i = 0; i < 24; i++) {
if (gameState.board[i] === 0) validMoveTargets.push(i);
}
} else {
validMoveTargets = ADJACENCY[gameState.selectedNode].filter(pos => gameState.board[pos] === 0);
}
}
for (let i = 0; i < 24; i++) {
const node = document.getElementById('node-' + i);
node.className = 'node';
if (gameState.board[i] === 1) node.classList.add('p1');
if (gameState.board[i] === 2) node.classList.add('p2');
if (i === gameState.selectedNode) node.classList.add('selected');
if (validMoveTargets.includes(i)) {
node.classList.add('move-target');
}
if (gameState.mustRemove) {
const opponent = gameState.turn === 1 ? 2 : 1;
if (gameState.board[i] === opponent) {
if (!checkMill(i, gameState.board) || allPiecesInMill(opponent, gameState.board)) {
node.classList.add('highlight');
}
}
}
}
const p1BoardCount = countPieces(1, gameState.board);
const p2BoardCount = countPieces(2, gameState.board);
if (gameState.phase === 1) {
p1CountEl.textContent = gameState.p1Hand;
p2CountEl.textContent = gameState.p2Hand;
} else {
p1CountEl.textContent = p1BoardCount;
p2CountEl.textContent = p2BoardCount;
}
if (gameState.turn === 1) {
turnInfo.textContent = "Your Turn";
turnInfo.style.color = "var(--p1-color)";
turnInfo.classList.remove('thinking');
} else {
turnInfo.textContent = "AI is thinking...";
turnInfo.style.color = "var(--p2-color)";
turnInfo.classList.add('thinking');
}
if (gameState.mustRemove) {
phaseInfo.textContent = gameState.turn === 1 ? "REMOVE OPPONENT PIECE" : "AI REMOVING PIECE...";
} else if (gameState.phase === 1) {
phaseInfo.textContent = "PHASE: PLACING (Pieces in hand)";
} else {
const currentPlayerPieces = gameState.turn === 1 ? p1BoardCount : p2BoardCount;
if (currentPlayerPieces === 3 && gameState.p1Hand === 0 && gameState.p2Hand === 0) {
phaseInfo.textContent = "PHASE: FLYING";
} else {
phaseInfo.textContent = "PHASE: MOVING";
}
}
}
function startGame() {
SoundEngine.playMove();
gameState = {
board: Array(24).fill(0),
turn: 1,
phase: 1,
p1Hand: 9,
p2Hand: 9,
selectedNode: -1,
mustRemove: false,
gameOver: false
};
overlay.style.display = 'none';
log('New Game Started', 'highlight');
renderStaticBoard();
updateView();
boardEl.classList.add('board-fade');
setTimeout(() => boardEl.classList.remove('board-fade'), 50);
}
function handleInput(idx) {
if (gameState.gameOver || gameState.turn !== 1) {
if (gameState.gameOver) SoundEngine.playError();
return;
}
if (gameState.mustRemove) {
if (removePiece(idx, 1)) {
endTurn();
} else {
SoundEngine.playError();
log('Invalid removal choice', 'error');
}
return;
}
if (gameState.phase === 1) {
if (gameState.board[idx] === 0) {
makeMove({
type: 'place',
to: idx
}, 1);
} else {
SoundEngine.playError();
log('Spot already occupied', 'error');
}
} else {
const p1Pieces = countPieces(1, gameState.board);
const isFlying = p1Pieces === 3 && gameState.p1Hand === 0 && gameState.p2Hand === 0;
if (gameState.selectedNode === -1) {
if (gameState.board[idx] === 1) {
gameState.selectedNode = idx;
SoundEngine.playMove();
updateView();
}
} else {
if (idx === gameState.selectedNode) {
gameState.selectedNode = -1;
SoundEngine.playMove();
updateView();
} else if (gameState.board[idx] === 1) {
gameState.selectedNode = idx;
SoundEngine.playMove();
updateView();
} else if (gameState.board[idx] === 0) {
if (isFlying || ADJACENCY[gameState.selectedNode].includes(idx)) {
makeMove({
type: 'move',
from: gameState.selectedNode,
to: idx
}, 1);
} else {
SoundEngine.playError();
log('Invalid move', 'error');
}
}
}
}
}
function makeMove(move, player) {
let formedMill = false;
SoundEngine.playMove();
if (move.type === 'place') {
gameState.board[move.to] = player;
if (player === 1) gameState.p1Hand--;
else gameState.p2Hand--;
if (checkMill(move.to, gameState.board)) formedMill = true;
log(player === 1 ? 'You placed a piece' : 'AI placed a piece');
} else if (move.type === 'move') {
gameState.board[move.from] = 0;
gameState.board[move.to] = player;
gameState.selectedNode = -1;
if (checkMill(move.to, gameState.board)) formedMill = true;
log(player === 1 ? 'You moved a piece' : 'AI moved a piece');
}
if (formedMill) {
gameState.mustRemove = true;
SoundEngine.playTone(600, 'sine', 0.2);
log(player === 1 ? 'Mill formed! Remove AI piece.' : 'AI formed a mill!', 'highlight');
updateView();
if (player === 2) {
setTimeout(aiRemove, 700);
}
} else {
endTurn();
}
}
function removePiece(idx, player) {
const opponent = player === 1 ? 2 : 1;
if (gameState.board[idx] !== opponent) return false;
if (checkMill(idx, gameState.board) && !allPiecesInMill(opponent, gameState.board)) return false;
gameState.board[idx] = 0;
gameState.mustRemove = false;
SoundEngine.playCapture();
log(player === 1 ? 'You removed an AI piece' : 'AI removed your piece', 'error');
updateView();
return true;
}
function endTurn() {
if (gameState.p1Hand === 0 && gameState.p2Hand === 0 && gameState.phase === 1) {
gameState.phase = 2;
log('Phase 2: Movement Phase Started', 'highlight');
}
gameState.turn = gameState.turn === 1 ? 2 : 1;
if (checkWin()) return;
updateView();
if (gameState.turn === 2) {
setTimeout(aiTurn, 500);
}
}
function checkMill(idx, board) {
const p = board[idx];
if (p === 0) return false;
return MILLS.some(m => m.includes(idx) && m.every(pos => board[pos] === p));
}
function allPiecesInMill(player, board) {
for (let i = 0; i < 24; i++) {
if (board[i] === player && !checkMill(i, board)) return false;
}
return true;
}
function countPieces(player, board) {
return board.filter(x => x === player).length;
}
function checkWin() {
const p1 = countPieces(1, gameState.board);
const p2 = countPieces(2, gameState.board);
if (gameState.phase !== 1) {
if (p1 < 3) return declareWinner(2);
if (p2 < 3) return declareWinner(1);
if (generateMoves(gameState.turn, gameState.board, 0, 0).length === 0) {
return declareWinner(gameState.turn === 1 ? 2 : 1);
}
}
return false;
}
function declareWinner(winner) {
gameState.gameOver = true;
winnerText.textContent = winner === 1 ? "You Win!" : "AI Wins!";
winnerText.style.color = winner === 1 ? "var(--p1-color)" : "var(--p2-color)";
if (winner === 1) SoundEngine.playWin();
else SoundEngine.playLose();
log(winner === 1 ? 'VICTORY!' : 'DEFEAT!', 'highlight');
turnInfo.textContent = "Game Over";
turnInfo.classList.remove('thinking');
phaseInfo.textContent = `Winner: ${winner === 1 ? "Player" : "AI"}`;
overlay.style.display = 'flex';
return true;
}
function aiTurn() {
const depth = parseInt(document.getElementById('difficulty-select').value);
const move = getBestMove(depth, gameState.p1Hand, gameState.p2Hand);
if (move) makeMove(move, 2);
}
function aiRemove() {
const pieceToRemove = getBestPieceToRemove(2, gameState.board);
if (pieceToRemove !== -1) {
removePiece(pieceToRemove, 2);
}
endTurn();
}
function getBestPieceToRemove(playerMakingMill, board) {
const opponent = playerMakingMill === 1 ? 2 : 1;
const candidates = [];
const allOpponentPiecesInMill = allPiecesInMill(opponent, board);
const removablePieces = [];
for (let i = 0; i < 24; i++) {
if (board[i] === opponent) {
if (allOpponentPiecesInMill || !checkMill(i, board)) {
removablePieces.push(i);
}
}
}
if (removablePieces.length === 0) return -1;
for (const idx of removablePieces) {
let score = 0;
score += countPotentialMillsForPiece(idx, board) * 100;
const mobility = ADJACENCY[idx].filter(n => board[n] === 0).length;
score += mobility * 10;
candidates.push({
idx,
score
});
}
candidates.sort((a, b) => b.score - a.score);
return candidates[0].idx;
}
function getAppliedBoard(move, board, player) {
const nb = [...board];
if (move.type === 'place') {
nb[move.to] = player;
} else {
nb[move.from] = 0;
nb[move.to] = player;
}
return nb;
}
function getBestMove(depth, p1Hand, p2Hand) {
let moves = generateMoves(2, gameState.board, p1Hand, p2Hand);
if (moves.length === 0) return null;
let bestScore = -Infinity;
let bestMove = moves[0];
let alpha = -Infinity;
let beta = Infinity;
for (let m of moves) {
const newBoard = getAppliedBoard(m, gameState.board, 2);
let score;
let newP2Hand = p2Hand;
if (m.type === 'place') newP2Hand--;
if (checkMill(m.to, newBoard)) {
let millEval = -Infinity;
const removablePieces = [];
const opponent = 1;
const allOpponentPiecesInMill = allPiecesInMill(opponent, newBoard);
for (let i = 0; i < 24; i++) {
if (newBoard[i] === opponent && (allOpponentPiecesInMill || !checkMill(i, newBoard))) {
removablePieces.push(i);
}
}
if (removablePieces.length === 0) {
score = minimax(newBoard, depth - 1, false, alpha, beta, p1Hand, newP2Hand);
} else {
for (const pieceIdx of removablePieces) {
const boardAfterRemoval = [...newBoard];
boardAfterRemoval[pieceIdx] = 0;
millEval = Math.max(millEval, minimax(boardAfterRemoval, depth - 1, false, alpha, beta, p1Hand, newP2Hand));
}
score = millEval;
}
} else {
score = minimax(newBoard, depth - 1, false, alpha, beta, p1Hand, newP2Hand);
}
if (score > bestScore) {
bestScore = score;
bestMove = m;
}
alpha = Math.max(alpha, score);
if (beta <= alpha) break;
}
return bestMove;
}
function minimax(board, depth, isMax, alpha, beta, p1Hand, p2Hand) {
const player = isMax ? 2 : 1;
const opponent = isMax ? 1 : 2;
const p1Count = countPieces(1, board);
const p2Count = countPieces(2, board);
if (p1Hand === 0 && p2Hand === 0) {
if (p1Count < 3) return 10000 + depth;
if (p2Count < 3) return -10000 - depth;
}
const moves = generateMoves(player, board, p1Hand, p2Hand);
if (moves.length === 0) {
return isMax ? -10000 - depth : 10000 + depth;
}
if (depth === 0) return evaluate(board, p1Hand, p2Hand);
if (isMax) {
let maxEval = -Infinity;
for (let m of moves) {
const newBoard = getAppliedBoard(m, board, player);
let nextP2Hand = p2Hand;
if (m.type === 'place') nextP2Hand--;
let eval;
if (checkMill(m.to, newBoard)) {
let millEval = -Infinity;
const removablePieces = [];
const allOpponentPiecesInMill = allPiecesInMill(opponent, newBoard);
for (let i = 0; i < 24; i++) {
if (newBoard[i] === opponent && (allOpponentPiecesInMill || !checkMill(i, newBoard))) {
removablePieces.push(i);
}
}
if (removablePieces.length === 0) {
eval = minimax(newBoard, depth - 1, false, alpha, beta, p1Hand, nextP2Hand);
} else {
for (const pieceIdx of removablePieces) {
const boardAfterRemoval = [...newBoard];
boardAfterRemoval[pieceIdx] = 0;
millEval = Math.max(millEval, minimax(boardAfterRemoval, depth - 1, false, alpha, beta, p1Hand, nextP2Hand));
}
eval = millEval;
}
} else {
eval = minimax(newBoard, depth - 1, false, alpha, beta, p1Hand, nextP2Hand);
}
maxEval = Math.max(maxEval, eval);
alpha = Math.max(alpha, eval);
if (beta <= alpha) break;
}
return maxEval;
} else {
let minEval = Infinity;
for (let m of moves) {
const newBoard = getAppliedBoard(m, board, player);
let nextP1Hand = p1Hand;
if (m.type === 'place') nextP1Hand--;
let eval;
if (checkMill(m.to, newBoard)) {
let millEval = Infinity;
const removablePieces = [];
const allOpponentPiecesInMill = allPiecesInMill(opponent, newBoard);
for (let i = 0; i < 24; i++) {
if (newBoard[i] === opponent && (allOpponentPiecesInMill || !checkMill(i, newBoard))) {
removablePieces.push(i);
}
}
if (removablePieces.length === 0) {
eval = minimax(newBoard, depth - 1, true, alpha, beta, nextP1Hand, p2Hand);
} else {
for (const pieceIdx of removablePieces) {
const boardAfterRemoval = [...newBoard];
boardAfterRemoval[pieceIdx] = 0;
millEval = Math.min(millEval, minimax(boardAfterRemoval, depth - 1, true, alpha, beta, nextP1Hand, p2Hand));
}
eval = millEval;
}
} else {
eval = minimax(newBoard, depth - 1, true, alpha, beta, nextP1Hand, p2Hand);
}
minEval = Math.min(minEval, eval);
beta = Math.min(beta, eval);
if (beta <= alpha) break;
}
return minEval;
}
}
function generateMoves(player, board, p1Hand, p2Hand) {
let moves = [];
const currentHand = player === 1 ? p1Hand : p2Hand;
const isPlacing = currentHand > 0;
if (isPlacing) {
for (let i = 0; i < 24; i++) {
if (board[i] === 0) moves.push({
type: 'place',
to: i
});
}
} else {
const pieceCount = countPieces(player, board);
const isFlying = pieceCount === 3 && p1Hand === 0 && p2Hand === 0;
for (let i = 0; i < 24; i++) {
if (board[i] === player) {
if (isFlying) {
for (let j = 0; j < 24; j++)
if (board[j] === 0) moves.push({
type: 'move',
from: i,
to: j
});
} else {
for (let n of ADJACENCY[i])
if (board[n] === 0) moves.push({
type: 'move',
from: i,
to: n
});
}
}
}
}
return moves.sort(() => Math.random() - 0.5);
}
function evaluate(board, p1Hand, p2Hand) {
const aiCount = countPieces(2, board);
const p1Count = countPieces(1, board);
let score = (aiCount - p1Count) * 100;
if (p1Hand === 0 && p2Hand === 0) {
let aiMobility = 0;
let p1Mobility = 0;
const isP1Flying = p1Count === 3;
const isAiFlying = aiCount === 3;
const emptyNodes = 24 - (p1Count + aiCount);
for (let i = 0; i < 24; i++) {
if (board[i] === 2) {
if (isAiFlying) {
aiMobility = emptyNodes;
} else {
ADJACENCY[i].forEach(n => {
if (board[n] === 0) aiMobility++;
});
}
}
if (board[i] === 1) {
if (isP1Flying) {
p1Mobility = emptyNodes;
} else {
ADJACENCY[i].forEach(n => {
if (board[n] === 0) p1Mobility++;
});
}
}
}
if (isAiFlying && aiMobility === 0) return -10000;
if (isP1Flying && p1Mobility === 0) return 10000;
score += (aiMobility - p1Mobility) * 2;
}
let aiPotential = 0;
let p1Potential = 0;
MILLS.forEach(m => {
const b0 = board[m[0]];
const b1 = board[m[1]];
const b2 = board[m[2]];
const pieces = [b0, b1, b2];
const aiInMill = pieces.filter(p => p === 2).length;
const p1InMill = pieces.filter(p => p === 1).length;
const emptyInMill = pieces.filter(p => p === 0).length;
if (aiInMill === 2 && emptyInMill === 1) aiPotential++;
if (p1InMill === 2 && emptyInMill === 1) p1Potential++;
});
score += (aiPotential * 25);
score -= (p1Potential * 20);
return score;
}
function countPotentialMillsForPiece(idx, board) {
const player = board[idx];
if (player === 0) return 0;
let potentialMills = 0;
const relevantMills = MILLS.filter(m => m.includes(idx));
for (const mill of relevantMills) {
const pieces = mill.map(p => board[p]);
const playerCount = pieces.filter(p => p === player).length;
const emptyCount = pieces.filter(p => p === 0).length;
if (playerCount === 2 && emptyCount === 1) {
potentialMills++;
}
}
return potentialMills;
}
renderStaticBoard();
updateView();
</script>
</body>
</html>