<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mini Golf</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
<style>
:root {
--bg-dark: #010c01;
--bg-medium: #051505;
--bg-light: #0a2a0a;
--accent-green-bright: #39ff14;
--accent-green-medium: #0f0;
--accent-green-dark: #0a4d0a;
--text-color: #a7ff9d;
--player-color: #00ffff;
--ai-color: #ffff00;
--obstacle-color: #ff1493;
--turtle-color: #228B22;
--turtle-shell: #90EE90;
}
*,
*::before,
*::after {
box-sizing: border-box;
}
html,
body {
width: 100%;
height: 99.9%;
margin: 0;
padding: 0;
overflow: hidden;
}
body {
background: radial-gradient(circle, var(--bg-light) 0%, var(--bg-dark) 100%);
color: var(--text-color);
font-family: 'VT323', monospace;
display: flex;
}
#game-container {
flex-grow: 1;
display: flex;
justify-content: center;
align-items: center;
height: 100%;
padding: 0;
}
canvas {
background-color: var(--bg-medium);
border: 2px solid var(--accent-green-medium);
box-shadow: 0 0 35px var(--accent-green-medium), inset 0 0 20px var(--accent-green-dark);
cursor: crosshair;
max-width: 100%;
max-height: 100%;
object-fit: contain;
display: block;
border-radius: 10px;
}
.score-display {
color: var(--text-color);
font-size: 1.2em;
height: auto;
margin-bottom: 15px;
text-align: center;
letter-spacing: 1px;
}
h1 {
font-size: 3.5rem;
color: var(--accent-green-bright);
text-shadow: 0 0 15px var(--accent-green-bright);
letter-spacing: 3px;
margin: 0 0 20px 0;
}
.info-panel {
width: 320px;
flex-shrink: 0;
padding: 20px;
border-left: 2px solid var(--accent-green-medium);
box-shadow: -5px 0 25px var(--accent-green-medium);
background-color: rgba(5, 21, 5, 0.8);
backdrop-filter: blur(5px);
text-align: center;
overflow-y: auto;
height: 100%;
display: flex;
flex-direction: column;
justify-content: center;
}
.info-panel p,
.info-panel li {
color: var(--text-color);
font-size: 1.1em;
line-height: 1;
text-align: left;
}
.info-panel ul {
padding-left: 10px;
list-style-type: '>';
}
.info-panel li::marker {
padding-right: 12px;
}
.hidden {
display: none;
}
.game-button {
padding: 15px 30px;
font-family: 'VT323', monospace;
font-size: 1.8em;
color: var(--accent-green-bright);
background-color: transparent;
border: 2px solid var(--accent-green-medium);
box-shadow: 0 0 15px var(--accent-green-medium), inset 0 0 10px var(--accent-green-dark);
cursor: pointer;
text-shadow: 0 0 10px var(--accent-green-bright);
margin-top: 25px;
transition: all 0.3s ease;
border-radius: 5px;
}
.game-button:hover,
.game-button:focus {
background-color: var(--bg-light);
color: #fff;
box-shadow: 0 0 25px var(--accent-green-bright), inset 0 0 15px var(--accent-green-dark);
transform: translateY(-3px);
}
.game-button:active {
transform: translateY(1px);
}
#play-again-btn {
display: none;
}
</style>
</head>
<body>
<div id="game-container">
<canvas id="gameCanvas"></canvas>
</div>
<div class="info-panel">
<h1>MINI GOLF</h1>
<button style="display: block; margin: 0 auto 0 auto; background: transparent; border: 1px solid green; color: cornflowerblue; padding: 4px 4px 4px 4px; font-size: 1rem; border-radius: 4px; cursor: pointer; font-family: inherit; transition: all 0.2s ease; text-transform: uppercase; letter-spacing: 0.5px; box-shadow: 0 0 5px rgba(138, 43, 226, 0.2);" onclick="window.open('https://vanillahero.com', '_blank')">VanillaHero.com</button>
<p id="turn-indicator" class="score-display hidden">Your turn. Aim and shoot!</p>
<p id="score-1" class="score-display hidden">
Hole: <span id="hole-number">1</span>/<span id="total-holes">10</span> |
You: <span id="player-strokes">0</span> |
AI: <span id="ai-strokes">0</span>
</p>
<p id="score-2" class="score-display hidden">
Total You: <span id="player-total">0</span> |
Total AI: <span id="ai-total">0</span>
</p>
<p>The goal is to complete 10 holes with the fewest strokes.</p>
<ul>
<li>Click and drag from your ball (cyan) to aim. Release to shoot.</li>
<li>Watch out for the wandering turtle! If you hit it, you forfeit the hole.</li>
<li>The player with the fewest strokes after 10 holes wins.</li>
</ul>
<button id="start-game-btn" class="game-button">Start Game</button>
<button id="play-again-btn" class="game-button">Play Again</button>
</div>
<script>
'use strict';
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const CONSTANTS = {
LOGICAL_WIDTH: 800,
LOGICAL_HEIGHT: 600,
TOTAL_HOLES: 10,
BALL_RADIUS: 10,
FRICTION: 0.98,
PLAYER_MAX_POWER: 18,
HOLE_RADIUS: 20,
HOLE_GRAVITY: 0.2,
MAX_SPEED_TO_SINK: 16.0,
RESTITUTION: 0.9,
STOP_THRESHOLD: 0.01,
TURTLE_RADIUS: 15,
TURTLE_SPEED: 40,
TURTLE_PENALTY_STROKES: 10,
AI_THINK_TIME_MS: 1000,
AI_PUTT_DISTANCE: 150,
AI_MAX_POWER: 18,
PLAYER_BALL_COLOR: '#00ffff',
AI_BALL_COLOR: '#ffff00',
OBSTACLE_COLOR: '#ff1493',
SQUARE_OBSTACLE_COLOR: '#ffff00',
DIAMOND_OBSTACLE_COLOR: '#0000ff',
TURTLE_COLOR: '#228B22',
HOLE_STROKE_COLOR: '#39ff14',
};
const ui = {
turn: document.getElementById('turn-indicator'),
hole: document.getElementById('hole-number'),
totalHoles: document.getElementById('total-holes'),
playerStroles: document.getElementById('player-strokes'),
aiStrokes: document.getElementById('ai-strokes'),
playerTotal: document.getElementById('player-total'),
aiTotal: document.getElementById('ai-total'),
playAgainBtn: document.getElementById('play-again-btn'),
startGameBtn: document.getElementById('start-game-btn'),
score1: document.getElementById('score-1'),
score2: document.getElementById('score-2'),
};
let audioContext;
const soundEffects = {};
async function initAudio() {
if (audioContext) return;
try {
audioContext = new(window.AudioContext || window.webkitAudioContext)();
soundEffects.putt = await createPuttSound();
soundEffects.bounce = await createBounceSound();
soundEffects.sink = await createSinkSound();
soundEffects.penalty = await createPenaltySound();
soundEffects.start = await createUISound(440, 0.1, 'triangle');
soundEffects.click = await createUISound(880, 0.05, 'sine');
} catch (e) {
console.error("Web Audio API is not supported in this browser or could not start.", e);
}
}
function playSound(name, volume = 1, playbackRate = 1) {
if (!audioContext || !soundEffects[name]) return;
const source = audioContext.createBufferSource();
source.buffer = soundEffects[name];
source.playbackRate.value = playbackRate;
const gainNode = audioContext.createGain();
gainNode.gain.value = volume;
source.connect(gainNode).connect(audioContext.destination);
source.start();
}
function createSoundBuffer(generatorFn) {
const duration = 1;
const sampleRate = audioContext.sampleRate;
const frameCount = sampleRate * duration;
const buffer = audioContext.createBuffer(1, frameCount, sampleRate);
const data = buffer.getChannelData(0);
generatorFn(data, frameCount, sampleRate);
return Promise.resolve(buffer);
}
function createPuttSound() {
return createSoundBuffer((data, fc, sr) => {
const decay = 5;
for (let i = 0; i < fc; i++) {
if (i / sr > 0.1) break;
const t = i / sr;
data[i] = Math.sin(t * 2 * Math.PI * 150) * Math.exp(-t * decay) * 0.8;
}
});
}
function createBounceSound() {
return createSoundBuffer((data, fc, sr) => {
const decay = 25;
for (let i = 0; i < fc; i++) {
if (i / sr > 0.2) break;
const t = i / sr;
data[i] = (Math.random() * 2 - 1) * Math.exp(-t * decay) * 0.5;
}
});
}
function createSinkSound() {
return createSoundBuffer((data, fc, sr) => {
let t = 0;
let freq = 1200;
let amp = 0.5;
for (let i = 0; i < 5; i++) {
const duration = 0.05;
for (let j = 0; j < sr * duration; j++) {
const idx = Math.floor(t * sr) + j;
if (idx >= fc) break;
data[idx] = Math.sin(j / sr * 2 * Math.PI * freq) * amp;
}
t += duration + 0.02;
freq *= 0.8;
amp *= 0.7;
}
});
}
function createPenaltySound() {
return createSoundBuffer((data, fc, sr) => {
const decay = 10;
for (let i = 0; i < fc; i++) {
if (i / sr > 0.5) break;
const t = i / sr;
const s1 = Math.sin(t * 2 * Math.PI * 220);
const s2 = Math.sin(t * 2 * Math.PI * 233);
data[i] = (s1 + s2) * 0.5 * Math.exp(-t * decay) * 0.7;
}
});
}
function createUISound(freq, duration, type) {
return createSoundBuffer((data, fc, sr) => {
const decay = 1 / duration;
for (let i = 0; i < fc; i++) {
if (i / sr > duration) break;
const t = i / sr;
if (type === 'triangle') {
data[i] = (Math.abs((t * freq) % 1.0 - 0.5) * 4 - 1) * Math.exp(-t * decay) * 0.5;
} else {
data[i] = Math.sin(t * 2 * Math.PI * freq) * Math.exp(-t * decay) * 0.5;
}
}
});
}
let gameState = 'PRE_GAME';
let currentHole = 1;
let scores = {
player: {
current: 0,
total: 0
},
ai: {
current: 0,
total: 0
}
};
const startPos = {
x: 70,
y: 300
};
let playerBall = {
x: startPos.x,
y: startPos.y,
dx: 0,
dy: 0,
radius: CONSTANTS.BALL_RADIUS,
inHole: false
};
let aiBall = {
x: startPos.x,
y: startPos.y,
dx: 0,
dy: 0,
radius: CONSTANTS.BALL_RADIUS,
inHole: false
};
let hole = {
x: 750,
y: 300,
radius: CONSTANTS.HOLE_RADIUS
};
let obstacles = [];
let turtle = {
x: 400,
y: 100,
dx: 0.8,
dy: 1,
radius: CONSTANTS.TURTLE_RADIUS
};
let particles = [];
let shooting = {
active: false,
x: 0,
y: 0
};
let transitionMessage = '';
let finalMessage = '';
let lastTime = 0;
function startGame() {
initAudio().then(() => playSound('start'));
ui.startGameBtn.style.display = 'none';
ui.turn.classList.remove('hidden');
ui.score1.classList.remove('hidden');
ui.score2.classList.remove('hidden');
lastTime = performance.now();
resetGame();
}
function resetGame() {
playSound('start');
currentHole = 1;
scores = {
player: {
current: 0,
total: 0
},
ai: {
current: 0,
total: 0
}
};
finalMessage = '';
transitionMessage = '';
ui.playAgainBtn.style.display = 'none';
generateCourse();
updateUI();
gameState = 'PLAYER_TURN';
ui.turn.innerText = 'Your turn. Aim and shoot!';
}
function switchTurn() {
const lastState = gameState;
if (lastState !== 'PLAYER_SHOOTING' && lastState !== 'AI_SHOOTING') return;
if (lastState === 'PLAYER_SHOOTING') {
gameState = aiBall.inHole ? 'PLAYER_TURN' : 'AI_TURN';
} else if (lastState === 'AI_SHOOTING') {
gameState = playerBall.inHole ? 'AI_TURN' : 'PLAYER_TURN';
}
if (gameState === 'AI_TURN') {
ui.turn.innerText = 'AI is thinking...';
setTimeout(aiShoot, CONSTANTS.AI_THINK_TIME_MS);
} else if (gameState === 'PLAYER_TURN') {
ui.turn.innerText = 'Your turn. Aim and shoot!';
}
}
function checkRoundEnd() {
if (playerBall.inHole && aiBall.inHole) {
startTransition();
return true;
}
return false;
}
function endRoundWithPenalty() {
playSound('penalty');
gameState = 'TRANSITION';
transitionMessage = 'You hit the turtle!';
scores.player.current = CONSTANTS.TURTLE_PENALTY_STROKES;
scores.ai.current = Math.max(1, scores.ai.current);
playerBall.inHole = true;
aiBall.inHole = true;
updateUI();
setTimeout(startTransition, 2000);
}
function startTransition() {
gameState = 'TRANSITION';
if (!transitionMessage) {
transitionMessage = `Hole ${currentHole} Complete!`;
}
scores.player.total += scores.player.current;
scores.ai.total += scores.ai.current;
updateUI();
if (currentHole >= CONSTANTS.TOTAL_HOLES) {
finalMessage = `You: ${scores.player.total} | AI: ${scores.ai.total}. `;
if (scores.player.total < scores.ai.total) {
finalMessage += 'You win!';
} else if (scores.ai.total < scores.player.total) {
finalMessage += 'AI wins!';
} else {
finalMessage += "It's a tie!";
}
ui.playAgainBtn.style.display = 'block';
} else {
setTimeout(startNextHole, 2500);
}
}
function startNextHole() {
playSound('start', 0.8, 1.2);
currentHole++;
scores.player.current = 0;
scores.ai.current = 0;
transitionMessage = '';
finalMessage = '';
updateUI();
generateCourse();
gameState = 'PLAYER_TURN';
ui.turn.innerText = 'Your turn. Aim and shoot!';
}
function generateCourse() {
obstacles = [];
playerBall = {
...playerBall,
x: startPos.x,
y: startPos.y,
dx: 0,
dy: 0,
inHole: false
};
aiBall = {
...aiBall,
x: startPos.x,
y: startPos.y,
dx: 0,
dy: 0,
inHole: false
};
spawnTurtle();
const obstacleTypes = ['circle', 'square', 'diamond'];
const getObstacleProps = () => {
const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
let color;
switch (type) {
case 'square':
color = CONSTANTS.SQUARE_OBSTACLE_COLOR;
break;
case 'diamond':
color = CONSTANTS.DIAMOND_OBSTACLE_COLOR;
break;
case 'circle':
default:
color = CONSTANTS.OBSTACLE_COLOR;
break;
}
return {
type,
color,
radius: Math.random() * 15 + CONSTANTS.BALL_RADIUS + 5
};
};
const tempReservedAreas = [{
x: startPos.x,
y: startPos.y,
radius: 40
}, {
x: turtle.x,
y: turtle.y,
radius: turtle.radius + CONSTANTS.BALL_RADIUS
}];
let holeCircle;
do {
hole.x = Math.random() * (canvas.width / 2 - 100) + canvas.width / 2;
hole.y = Math.random() * (canvas.height - 100) + 50;
holeCircle = {
x: hole.x,
y: hole.y,
radius: hole.radius + CONSTANTS.BALL_RADIUS * 1.5
};
} while (checkCircleOverlap(holeCircle, tempReservedAreas[0]) || checkCircleOverlap(holeCircle, tempReservedAreas[1]));
tempReservedAreas.push(holeCircle);
let blockingObstaclePlaced = false;
let attempts = 0;
const maxAttempts = 100;
while (!blockingObstaclePlaced && attempts < maxAttempts) {
attempts++;
const t = Math.random() * 0.4 + 0.3;
const pathX = startPos.x + (hole.x - startPos.x) * t;
const pathY = startPos.y + (hole.y - startPos.y) * t;
const pathAngle = Math.atan2(hole.y - startPos.y, hole.x - startPos.x);
const perpendicularAngle = pathAngle + Math.PI / 2;
const offsetMagnitude = (Math.random() - 0.5) * 60;
const potentialBlocker = {
x: pathX + Math.cos(perpendicularAngle) * offsetMagnitude,
y: pathY + Math.sin(perpendicularAngle) * offsetMagnitude,
...getObstacleProps()
};
let overlaps = false;
for (const area of [...tempReservedAreas, ...obstacles]) {
if (checkCircleOverlap(potentialBlocker, area)) {
overlaps = true;
break;
}
}
if (potentialBlocker.x - potentialBlocker.radius < 0 || potentialBlocker.x + potentialBlocker.radius > canvas.width ||
potentialBlocker.y - potentialBlocker.radius < 0 || potentialBlocker.y + potentialBlocker.radius > canvas.height) {
overlaps = true;
}
if (!overlaps) {
obstacles.push(potentialBlocker);
tempReservedAreas.push(potentialBlocker);
blockingObstaclePlaced = true;
}
}
const additionalObstacleCount = Math.floor(Math.random() * 4) + 2;
for (let i = 0; i < additionalObstacleCount; i++) {
let newObstacle, overlap, tries = 0;
do {
tries++;
if (tries > maxAttempts / 2) break; // Fewer tries for additional obstacles to prevent infinite loops
overlap = false;
newObstacle = {
x: Math.random() * (canvas.width - 200) + 100,
y: Math.random() * (canvas.height - 100) + 50,
...getObstacleProps()
};
for (const area of [...tempReservedAreas, ...obstacles]) {
if (checkCircleOverlap(newObstacle, area)) {
overlap = true;
break;
}
}
} while (overlap);
if (!overlap) obstacles.push(newObstacle);
}
}
function spawnTurtle() {
turtle.x = canvas.width / 2;
turtle.y = 50;
const angle = Math.random() * Math.PI * 2;
turtle.dx = Math.cos(angle);
turtle.dy = Math.sin(angle);
}
function aiShoot() {
if (aiBall.inHole) return;
scores.ai.current++;
playSound('putt', 0.7);
updateUI();
ui.turn.innerText = "AI's turn";
gameState = 'AI_SHOOTING';
let target;
let shotType = 'fallback';
if (isPathClear(aiBall, hole)) {
target = {
...hole
};
shotType = 'direct';
} else {
const bankShots = findAllBankShots();
if (bankShots.length > 0) {
let bestBankShot = bankShots[0];
let minPower = Infinity;
for (const shot of bankShots) {
const dist = Math.sqrt((shot.target.x - aiBall.x) ** 2 + (shot.target.y - aiBall.y) ** 2);
const power = dist / 23 + 1.5;
if (power < minPower) {
minPower = power;
bestBankShot = shot;
}
}
target = bestBankShot.target;
shotType = 'bank';
} else {
target = findAlternateTarget(aiBall, hole);
shotType = 'escape';
}
}
const distToTarget = Math.sqrt((target.x - aiBall.x) ** 2 + (target.y - aiBall.y) ** 2);
let power;
if (shotType === 'direct' && distToTarget < CONSTANTS.AI_PUTT_DISTANCE) {
power = distToTarget / 50;
} else if (shotType === 'direct') {
power = distToTarget / 35;
} else {
power = Math.min(distToTarget / 25 + 1, CONSTANTS.AI_MAX_POWER);
}
const angle = Math.atan2(target.y - aiBall.y, target.x - aiBall.x);
aiBall.dx = power * Math.cos(angle);
aiBall.dy = power * Math.sin(angle);
}
function findAlternateTarget(start, end) {
if (obstacles.length === 0) return end;
let bestTarget = null;
let minDistance = Infinity;
for (const ob of obstacles) {
const angleToObstacle = Math.atan2(ob.y - start.y, ob.x - start.x);
for (let side = -1; side <= 1; side += 2) {
const targetPoint = {
x: ob.x + Math.cos(angleToObstacle + (Math.PI / 2) * side) * (ob.radius + 15),
y: ob.y + Math.sin(angleToObstacle + (Math.PI / 2) * side) * (ob.radius + 15)
};
if (isPathClear(start, targetPoint)) {
const distToEnd = Math.sqrt((targetPoint.x - end.x) ** 2 + (targetPoint.y - end.y) ** 2);
if (distToEnd < minDistance) {
minDistance = distToEnd;
bestTarget = targetPoint;
}
}
}
}
return bestTarget || end;
}
function findAllBankShots() {
let validShots = [];
const surfaces = [{
p1: {
x: 0,
y: 0
},
p2: {
x: 0,
y: canvas.height
}
},
{
p1: {
x: canvas.width,
y: 0
},
p2: {
x: canvas.width,
y: canvas.height
}
},
{
p1: {
x: 0,
y: 0
},
p2: {
x: canvas.width,
y: 0
}
},
{
p1: {
x: 0,
y: canvas.height
},
p2: {
x: canvas.width,
y: canvas.height
}
},
];
for (const surface of surfaces) {
let reflectedHole;
if (surface.p1.x === surface.p2.x) {
reflectedHole = {
x: 2 * surface.p1.x - hole.x,
y: hole.y
};
} else {
reflectedHole = {
x: hole.x,
y: 2 * surface.p1.y - hole.y
};
}
if (isPathClear(aiBall, reflectedHole)) {
const intersectPoint = lineIntersect(aiBall, reflectedHole, surface.p1, surface.p2);
if (intersectPoint && isPathClear(intersectPoint, hole)) {
validShots.push({
target: reflectedHole
});
}
}
}
return validShots;
}
function moveBall(ball, deltaTime) {
if (ball.inHole) return;
const frictionMultiplier = Math.pow(CONSTANTS.FRICTION, deltaTime * 60);
ball.dx *= frictionMultiplier;
ball.dy *= frictionMultiplier;
handleHoleInteraction(ball, deltaTime);
ball.x += ball.dx * 60 * deltaTime;
ball.y += ball.dy * 60 * deltaTime;
checkCollisions(ball);
}
function moveTurtle(deltaTime) {
turtle.x += turtle.dx * CONSTANTS.TURTLE_SPEED * deltaTime;
turtle.y += turtle.dy * CONSTANTS.TURTLE_SPEED * deltaTime;
if (turtle.x + turtle.radius > canvas.width || turtle.x - turtle.radius < 0) turtle.dx *= -1;
if (turtle.y + turtle.radius > canvas.height || turtle.y - turtle.radius < 0) turtle.dy *= -1;
}
function handleHoleInteraction(ball, deltaTime) {
const dist = Math.sqrt((ball.x - hole.x) ** 2 + (ball.y - hole.y) ** 2);
if (dist < hole.radius) {
const gravity = CONSTANTS.HOLE_GRAVITY * 60 * deltaTime;
ball.dx -= (ball.x - hole.x) * gravity;
ball.dy -= (ball.y - hole.y) * gravity;
const speed = Math.sqrt(ball.dx ** 2 + ball.dy ** 2);
if (dist < 5 && speed < CONSTANTS.MAX_SPEED_TO_SINK) {
if (!ball.inHole) playSound('sink');
ball.inHole = true;
ball.dx = 0;
ball.dy = 0;
ball.x = hole.x;
ball.y = hole.y;
}
}
}
function checkCollisions(ball) {
const restitution = CONSTANTS.RESTITUTION;
let bounced = false;
const speed = Math.sqrt(ball.dx ** 2 + ball.dy ** 2);
if (ball.x + ball.radius > canvas.width) {
ball.x = canvas.width - ball.radius;
ball.dx *= -restitution;
bounced = true;
} else if (ball.x - ball.radius < 0) {
ball.x = ball.radius;
ball.dx *= -restitution;
bounced = true;
}
if (ball.y + ball.radius > canvas.height) {
ball.y = canvas.height - ball.radius;
ball.dy *= -restitution;
bounced = true;
} else if (ball.y - ball.radius < 0) {
ball.y = ball.radius;
ball.dy *= -restitution;
bounced = true;
}
obstacles.forEach((ob) => {
const dist = Math.sqrt((ball.x - ob.x) ** 2 + (ball.y - ob.y) ** 2);
if (dist < ball.radius + ob.radius) {
bounced = true;
const overlap = ball.radius + ob.radius - dist;
const nx = (ball.x - ob.x) / dist;
const ny = (ball.y - ob.y) / dist;
ball.x += overlap * nx;
ball.y += overlap * ny;
const dot = ball.dx * nx + ball.dy * ny;
ball.dx -= 2 * dot * nx * restitution;
ball.dy -= 2 * dot * ny * restitution;
}
});
if (bounced) {
const volume = Math.min(1, speed / 15);
playSound('bounce', volume);
}
}
function isBallStopped(ball) {
if (ball.inHole) return true;
if (Math.abs(ball.dx) < CONSTANTS.STOP_THRESHOLD && Math.abs(ball.dy) < CONSTANTS.STOP_THRESHOLD) {
ball.dx = 0;
ball.dy = 0;
return true;
}
return false;
}
function checkCircleOverlap(c1, c2) {
const dist = Math.sqrt((c1.x - c2.x) ** 2 + (c1.y - c2.y) ** 2);
return dist < c1.radius + c2.radius;
}
function isPathClear(start, end) {
if (lineCircleIntersect(start, end, turtle, CONSTANTS.TURTLE_RADIUS + CONSTANTS.BALL_RADIUS)) return false;
for (const ob of obstacles) {
if (lineCircleIntersect(start, end, ob, ob.radius + CONSTANTS.BALL_RADIUS)) return false;
}
return true;
}
function lineCircleIntersect(p1, p2, circle, radius) {
const dx = p2.x - p1.x;
const dy = p2.y - p1.y;
const a = dx * dx + dy * dy;
const b = 2 * (dx * (p1.x - circle.x) + dy * (p1.y - circle.y));
const c = (p1.x - circle.x) ** 2 + (p1.y - circle.y) ** 2 - radius ** 2;
if (a === 0) return false;
const delta = b * b - 4 * a * c;
if (delta < 0) return false;
const t1 = (-b - Math.sqrt(delta)) / (2 * a);
const t2 = (-b + Math.sqrt(delta)) / (2 * a);
return (t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1);
}
function lineIntersect(p1, p2, p3, p4) {
const den = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
if (den === 0) return null;
const t = ((p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x)) / den;
const u = -((p1.x - p2.x) * (p1.y - p3.y) - (p1.y - p2.y) * (p1.x - p3.x)) / den;
if (t > 0 && t < 1 && u >= 0 && u <= 1) {
return {
x: p1.x + t * (p2.x - p1.x),
y: p1.y + t * (p2.y - p1.y)
};
}
return null;
}
function createExplosion(x, y) {
for (let i = 0; i < 30; i++) {
particles.push({
x: x,
y: y,
dx: (Math.random() - 0.5) * 3,
dy: (Math.random() - 0.5) * 3,
life: 50,
color: `hsl(${Math.random() * 60 + 30}, 100%, 50%)`,
});
}
}
function updateParticles(deltaTime) {
for (let i = particles.length - 1; i >= 0; i--) {
const p = particles[i];
p.x += p.dx * 60 * deltaTime;
p.y += p.dy * 60 * deltaTime;
p.dy += 0.1 * 60 * deltaTime;
p.life -= 2 * 60 * deltaTime;
if (p.life <= 0) particles.splice(i, 1);
}
}
function update(deltaTime) {
if (gameState === 'PRE_GAME' || gameState === 'TRANSITION') return;
if (deltaTime > 0.1) deltaTime = 0.1;
moveTurtle(deltaTime);
updateParticles(deltaTime);
const distToTurtle = Math.sqrt((playerBall.x - turtle.x) ** 2 + (playerBall.y - turtle.y) ** 2);
if (!playerBall.inHole && gameState === 'PLAYER_SHOOTING' && distToTurtle < playerBall.radius + turtle.radius) {
createExplosion(playerBall.x, playerBall.y);
endRoundWithPenalty();
return;
}
if (gameState === 'PLAYER_SHOOTING') {
moveBall(playerBall, deltaTime);
if (isBallStopped(playerBall) || playerBall.inHole) {
checkRoundEnd() || switchTurn();
}
} else if (gameState === 'AI_SHOOTING') {
moveBall(aiBall, deltaTime);
if (isBallStopped(aiBall) || aiBall.inHole) {
checkRoundEnd() || switchTurn();
}
}
}
function draw() {
ctx.clearRect(0, 0, canvas.width, canvas.height);
const bgGradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, Math.max(canvas.width, canvas.height));
bgGradient.addColorStop(0, '#0a2a0a');
bgGradient.addColorStop(1, '#052005');
ctx.fillStyle = bgGradient;
ctx.fillRect(0, 0, canvas.width, canvas.height);
if (gameState === 'PRE_GAME') return;
const holeGradient = ctx.createRadialGradient(hole.x, hole.y, hole.radius * 0.2, hole.x, hole.y, hole.radius);
holeGradient.addColorStop(0, '#000');
holeGradient.addColorStop(1, '#111');
ctx.fillStyle = holeGradient;
ctx.strokeStyle = CONSTANTS.HOLE_STROKE_COLOR;
ctx.lineWidth = 2;
ctx.beginPath();
ctx.arc(hole.x, hole.y, hole.radius, 0, Math.PI * 2);
ctx.fill();
ctx.stroke();
obstacles.forEach((ob) => {
ctx.shadowColor = ob.color;
ctx.shadowBlur = 15;
const obsGradient = ctx.createRadialGradient(ob.x - ob.radius / 3, ob.y - ob.radius / 3, 0, ob.x, ob.y, ob.radius);
const darkerColor = `rgb(${Math.max(0, parseInt(ob.color.substring(1, 3), 16) - 50)}, ${Math.max(0, parseInt(ob.color.substring(3, 5), 16) - 50)}, ${Math.max(0, parseInt(ob.color.substring(5, 7), 16) - 50)})`;
obsGradient.addColorStop(0, '#ffffff');
obsGradient.addColorStop(0.5, ob.color);
obsGradient.addColorStop(1, darkerColor);
ctx.fillStyle = obsGradient;
ctx.beginPath();
if (ob.type === 'circle') {
ctx.arc(ob.x, ob.y, ob.radius, 0, Math.PI * 2);
} else if (ob.type === 'square') {
ctx.rect(ob.x - ob.radius, ob.y - ob.radius, ob.radius * 2, ob.radius * 2);
} else if (ob.type === 'diamond') {
ctx.moveTo(ob.x, ob.y - ob.radius);
ctx.lineTo(ob.x + ob.radius, ob.y);
ctx.lineTo(ob.x, ob.y + ob.radius);
ctx.lineTo(ob.x - ob.radius, ob.y);
ctx.closePath();
}
ctx.fill();
});
ctx.shadowBlur = 0;
drawTurtle();
if (!aiBall.inHole) drawBall(aiBall, 'AI', CONSTANTS.AI_BALL_COLOR);
if (!playerBall.inHole) drawBall(playerBall, 'You', CONSTANTS.PLAYER_BALL_COLOR);
drawParticles();
if (shooting.active) {
const dist = Math.sqrt((playerBall.x - shooting.x) ** 2 + (playerBall.y - shooting.y) ** 2);
const powerRatio = Math.min(dist / 10, CONSTANTS.PLAYER_MAX_POWER) / CONSTANTS.PLAYER_MAX_POWER;
const aimColor = `hsl(${(1 - powerRatio) * 120}, 100%, 50%)`;
ctx.beginPath();
ctx.moveTo(playerBall.x, playerBall.y);
ctx.lineTo(shooting.x, shooting.y);
ctx.strokeStyle = aimColor;
ctx.lineWidth = 3;
ctx.setLineDash([5, 10]);
ctx.stroke();
ctx.setLineDash([]);
}
if (gameState === 'TRANSITION') {
ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
ctx.fillRect(0, 0, canvas.width, canvas.height);
ctx.fillStyle = '#39ff14';
ctx.textAlign = 'center';
ctx.font = '50px "VT323"';
ctx.shadowColor = '#39ff14';
ctx.shadowBlur = 10;
ctx.fillText(transitionMessage, canvas.width / 2, canvas.height / 2 - 20);
if (finalMessage) {
ctx.font = '30px "VT323"';
ctx.fillText(finalMessage, canvas.width / 2, canvas.height / 2 + 40);
}
ctx.shadowBlur = 0;
}
}
function drawBall(ball, text, color) {
ctx.shadowColor = color;
ctx.shadowBlur = 20;
const gradient = ctx.createRadialGradient(
ball.x - ball.radius * 0.3, ball.y - ball.radius * 0.3, ball.radius * 0.1,
ball.x, ball.y, ball.radius
);
gradient.addColorStop(0, '#ffffff');
gradient.addColorStop(0.2, color);
gradient.addColorStop(1, color);
ctx.fillStyle = gradient;
ctx.beginPath();
ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
ctx.fill();
ctx.shadowBlur = 0;
ctx.fillStyle = '#000';
ctx.font = '14px "VT323"';
ctx.textAlign = 'center';
ctx.fillText(text, ball.x, ball.y + 5);
}
function drawTurtle() {
ctx.save();
ctx.translate(turtle.x, turtle.y);
ctx.shadowColor = '#90EE90';
ctx.shadowBlur = 10;
ctx.fillStyle = CONSTANTS.TURTLE_COLOR;
ctx.strokeStyle = '#90EE90';
ctx.lineWidth = 2;
ctx.beginPath();
ctx.arc(0, 0, turtle.radius, 0, Math.PI * 2);
ctx.fill();
ctx.stroke();
ctx.strokeStyle = 'rgba(144, 238, 144, 0.5)';
ctx.lineWidth = 1;
ctx.beginPath();
ctx.moveTo(0, -turtle.radius);
ctx.lineTo(0, turtle.radius);
ctx.moveTo(-turtle.radius, 0);
ctx.lineTo(turtle.radius, 0);
ctx.stroke();
ctx.restore();
ctx.shadowBlur = 0;
}
function drawParticles() {
particles.forEach((p) => {
ctx.fillStyle = p.color;
ctx.globalAlpha = Math.max(0, p.life / 50);
ctx.beginPath();
ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
ctx.fill();
});
ctx.globalAlpha = 1.0;
}
function gameLoop(currentTime) {
const deltaTime = (currentTime - lastTime) / 1000;
lastTime = currentTime;
update(deltaTime || 0);
draw();
requestAnimationFrame(gameLoop);
}
function updateUI() {
ui.hole.innerText = currentHole;
ui.totalHoles.innerText = CONSTANTS.TOTAL_HOLES;
ui.playerStroles.innerText = scores.player.current;
ui.aiStrokes.innerText = scores.ai.current;
ui.playerTotal.innerText = scores.player.total;
ui.aiTotal.innerText = scores.ai.total;
}
function getMousePos(e) {
const rect = canvas.getBoundingClientRect();
const scaleX = canvas.width / rect.width;
const scaleY = canvas.height / rect.height;
return {
x: (e.clientX - rect.left) * scaleX,
y: (e.clientY - rect.top) * scaleY,
};
}
function resizeCanvas() {
const container = document.getElementById('game-container');
const aspectRatio = canvas.width / canvas.height;
let newWidth = container.clientWidth;
let newHeight = container.clientHeight;
const containerAspectRatio = newWidth / newHeight;
if (containerAspectRatio > aspectRatio) {
newWidth = newHeight * aspectRatio;
} else {
newHeight = newWidth / aspectRatio;
}
canvas.style.width = `${newWidth}px`;
canvas.style.height = `${newHeight}px`;
}
ui.startGameBtn.addEventListener('click', () => {
playSound('click');
startGame();
});
ui.playAgainBtn.addEventListener('click', () => {
playSound('click');
resetGame();
});
canvas.addEventListener('mousedown', (e) => {
if (gameState === 'PLAYER_TURN') {
shooting.active = true;
const mousePos = getMousePos(e);
shooting.x = mousePos.x;
shooting.y = mousePos.y;
}
});
canvas.addEventListener('mouseup', (e) => {
if (!shooting.active) return;
shooting.active = false;
playSound('putt');
const mousePos = getMousePos(e);
gameState = 'PLAYER_SHOOTING';
scores.player.current++;
updateUI();
ui.turn.innerText = 'Shooting...';
const dx = mousePos.x - playerBall.x;
const dy = mousePos.y - playerBall.y;
const dist = Math.sqrt(dx * dx + dy * dy);
if (dist > 0) {
const power = Math.min(dist / 10, CONSTANTS.PLAYER_MAX_POWER);
playerBall.dx = (dx / dist) * power;
playerBall.dy = (dy / dist) * power;
}
});
canvas.addEventListener('mousemove', (e) => {
if (shooting.active) {
const mousePos = getMousePos(e);
shooting.x = mousePos.x;
shooting.y = mousePos.y;
}
});
window.addEventListener('resize', resizeCanvas);
canvas.width = CONSTANTS.LOGICAL_WIDTH;
canvas.height = CONSTANTS.LOGICAL_HEIGHT;
resizeCanvas();
requestAnimationFrame(gameLoop);
</script>
</body>
</html>