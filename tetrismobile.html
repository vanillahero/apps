<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Tetris Mobile</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text x=%2250%22 y=%2275%22 font-size=%2280%22 text-anchor=%22middle%22>%F0%9F%9F%A7</text></svg>">
<style>
:root {
--primary-color: #00ffff;
--secondary-color: #ff00ff;
--score-color: #00ff00;
--reward-color: #ffff00;
--dark-bg: #000000;
--black-bg: #111;
--text-color: #e0e0e0;
--game-over-color: #ff0000;
}
body {
display: flex;
justify-content: center;
align-items: center;
height: 100vh;
width: 100vw;
background-color: #121212;
color: var(--text-color);
overflow: hidden;
font-family: 'Courier New', Courier, monospace;
margin: 0;
padding: 0;
box-sizing: border-box;
touch-action: none;
overscroll-behavior: none;
}
.game-container {
display: flex;
flex-direction: column;
justify-content: center;
align-items: center;
width: 100%;
height: 100%;
position: relative;
background-color: var(--dark-bg);
padding-top: env(safe-area-inset-top);
padding-bottom: env(safe-area-inset-bottom);
}
.game-world {
display: flex;
flex-direction: column;
align-items: center;
}
.game-container.paused::before {
content: attr(data-pause-text);
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
display: flex;
justify-content: center;
align-items: center;
font-size: 15vmin;
color: var(--reward-color);
background-color: rgba(15, 15, 28, 0.85);
text-shadow: 0 0 2vh var(--reward-color);
z-index: 200;
pointer-events: none;
}
.top-bar {
display: flex;
justify-content: space-around;
align-items: center;
width: 100%;
padding: 0.5em 0;
background-color: #080808;
box-shadow: 0 0 0.8em rgba(0, 255, 255, 0.5);
border-bottom: 0.1em solid var(--primary-color);
}
.info-section {
text-align: center;
}
.info-section h2 {
font-size: 0.8em;
color: var(--score-color);
text-shadow: 0 0 0.3em var(--score-color);
margin: 0 0 0.2em 0;
}
.info-section p {
font-size: 1.2em;
color: var(--primary-color);
text-shadow: 0 0 0.2em var(--primary-color);
margin: 0;
}
.next-piece-container {
display: flex;
flex-direction: column;
align-items: center;
}
.next-piece-container h2 {
font-size: 0.8em;
color: var(--score-color);
margin: 0 0 0.2em 0;
}
#nextPieceCanvas {
background-color: #050505;
border: 0.08em solid var(--score-color);
box-shadow: 0 0 0.4em rgba(0, 255, 0, 0.5);
width: 4em;
height: 2.5em;
}
canvas#gameCanvas {
background-color: var(--black-bg);
border: 0.08em solid var(--primary-color);
box-shadow: 0 0 0.6em rgba(0, 255, 255, 0.5);
display: block;
margin-top: 0.8em;
user-select: none;
-webkit-user-select: none;
-webkit-touch-callout: none;
}
#pauseButton {
position: absolute;
bottom: 3vmin;
right: 3vmin;
width: 12vmin;
height: 12vmin;
font-size: 5vmin;
background-color: var(--secondary-color);
color: var(--dark-bg);
border: 0.3vmin solid #ff00cc;
border-radius: 50%;
cursor: pointer;
z-index: 50;
box-shadow: 0 0 2vmin rgba(255, 0, 255, 0.7);
transition: transform 0.2s, box-shadow 0.2s;
display: flex;
justify-content: center;
align-items: center;
}
#pauseButton:active {
transform: scale(0.95);
}
#instructions {
display: none;
margin: 3vmin 0;
width: 80%;
text-align: left;
}
#instructions h3 {
font-size: 5vmin;
color: var(--score-color);
text-shadow: 0 0 1.5vmin var(--score-color);
margin: 0 0 2vmin 0;
text-align: center;
}
#instructions ul {
padding-left: 0;
margin: 0;
font-size: 4vmin;
color: var(--text-color);
list-style-type: none;
}
#instructions li {
margin-bottom: 1.5vmin;
text-shadow: none;
}
.game-over-screen {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.9);
display: none;
flex-direction: column;
justify-content: center;
align-items: center;
font-size: 10vmin;
color: var(--game-over-color);
text-shadow: 0 0 2vmin var(--game-over-color);
z-index: 100;
text-align: center;
padding: 5vmin;
box-sizing: border-box;
}
#finalScore {
font-size: 8vmin;
color: var(--primary-color);
text-shadow: 0 0 1.5vmin var(--primary-color);
margin: 2vmin 0;
}
.game-over-highscores {
margin: 3vmin 0;
width: 80%;
}
.game-over-highscores h2 {
font-size: 5vmin;
color: var(--score-color);
text-shadow: 0 0 1.5vmin var(--score-color);
margin: 0 0 2vmin 0;
}
.game-over-highscores ol {
padding-left: 0;
margin: 0;
font-size: 4.5vmin;
color: var(--text-color);
list-style-type: none;
}
.game-over-highscores li {
margin-bottom: 1vmin;
text-shadow: 0 0 0.5vmin var(--primary-color);
}
.game-over-screen button {
background-color: var(--score-color);
color: var(--dark-bg);
border: 0.3vmin solid #00cc00;
padding: 3vmin 6vmin;
font-family: 'Courier New', Courier, monospace;
font-size: 4vmin;
cursor: pointer;
border-radius: 2vmin;
box-shadow: 0 0 1.5vmin rgba(0, 255, 0, 0.7);
transition: transform 0.2s, box-shadow 0.2s;
margin-top: 3vmin;
}
.game-over-screen button:active {
transform: scale(0.95);
}
#rotate-message {
display: none;
position: fixed;
top: 0;
left: 0;
width: 100vw;
height: 100vh;
background: #000;
color: #0f0;
flex-direction: column;
justify-content: center;
align-items: center;
z-index: 2147483647;
text-align: center;
}
#rotate-message svg {
width: 64px;
height: 64px;
fill: #0f0;
margin-bottom: 20px;
animation: rotate-to-portrait 2s infinite ease-in-out;
}
@keyframes rotate-to-portrait {
0%,
100% {
transform: rotate(90deg);
}
50% {
transform: rotate(0deg);
}
}
@media (orientation: landscape) {
#rotate-message {
display: flex;
}
}
</style>
</head>
<body>
<div id="rotate-message">
<svg viewBox="0 0 24 24">
<path d="M17,1.01L7,1C5.9,1 5,1.9 5,3v18c0,1.1 0.9,2 2,2h10c1.1,0 2,-0.9 2,-2V3C19,1.9 18.1,1.01 17,1.01z M17,21H7l0,-1h10V21z M17,18H7V6h10V18z M7,4V3h10v1H7z" />
</svg>
<p>PLEASE ROTATE DEVICE</p>
</div>
<div class="game-container">
<div class="game-world">
<div class="top-bar">
<div class="info-section">
<h2 id="score-label"></h2>
<p id="score">0</p>
</div>
<div class="next-piece-container">
<h2 id="next-label"></h2>
<canvas id="nextPieceCanvas"></canvas>
</div>
<div class="info-section">
<h2 id="level-label"></h2>
<p id="level">1</p>
</div>
</div>
<canvas id="gameCanvas"></canvas>
</div>
<button id="pauseButton">||</button>
<div class="game-over-screen" id="gameStatusScreen">
<div id="statusMessage"></div>
<p style="font-size: 1rem; margin: 0 0 0 0; color: CornFlowerBlue; text-align: center;">&copy; Johnny Heggelund</p>
<div id="instructions"></div>
<p id="finalScore"></p>
<div class="game-over-highscores">
<h2 id="highscore-title"></h2>
<ol id="highscore-list"></ol>
</div>
<button id="statusButton"></button>
</div>
</div>
<script>
const lang = {
title: "Tetris Mobile",
score: "Score",
level: "Level",
next: "Next",
highscoreTitle: "High Scores",
welcome: "Welcome",
startGame: "Tap to Start",
gameOver: "GAME OVER!",
playAgain: "Play Again",
pauseOverlay: "PAUSED",
yourScore: "Your Score: ",
noHighscores: "No high scores yet",
instructionsTitle: "Controls",
insMove: "â†”ï¸ Swipe Left/Right to Move",
insRotate: "ðŸ‘† Tap to Rotate",
insDrop: "â¬‡ï¸ Swipe Down to Drop",
insDropBonus: "ðŸŽ Bonus for fast drop!"
};
const gameCanvas = document.getElementById('gameCanvas');
const ctx = gameCanvas.getContext('2d');
const nextPieceCanvas = document.getElementById('nextPieceCanvas');
const nextPieceCtx = nextPieceCanvas.getContext('2d');
const scoreDisplay = document.getElementById('score');
const levelDisplay = document.getElementById('level');
const gameStatusScreen = document.getElementById('gameStatusScreen');
const statusMessage = document.getElementById('statusMessage');
const statusButton = document.getElementById('statusButton');
const gameContainer = document.querySelector('.game-container');
const gameWorld = document.querySelector('.game-world');
const highscoreList = document.getElementById('highscore-list');
const finalScoreDisplay = document.getElementById('finalScore');
const pauseButton = document.getElementById('pauseButton');
const instructions = document.getElementById('instructions');
const BOARD_WIDTH = 10;
const BOARD_HEIGHT = 20;
const HIGHSCORE_KEY = 'tetrisMobileHighscores';
const TETROMINOES = [
[
[0, 0, 0, 0],
[1, 1, 1, 1],
[0, 0, 0, 0],
[0, 0, 0, 0]
],
[
[1, 0, 0],
[1, 1, 1],
[0, 0, 0]
],
[
[0, 0, 1],
[1, 1, 1],
[0, 0, 0]
],
[
[1, 1],
[1, 1]
],
[
[0, 1, 1],
[1, 1, 0],
[0, 0, 0]
],
[
[0, 1, 0],
[1, 1, 1],
[0, 0, 0]
],
[
[1, 1, 0],
[0, 1, 1],
[0, 0, 0]
],
];
const COLORS = ['#00ffff', '#0000ff', '#ff8c00', '#ffff00', '#00ff00', '#ff00ff', '#ff0000'];
let blockSize;
let previewBlockSize;
let board = Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(0));
let currentPiece = null;
let nextPiece = null;
let score = 0;
let level = 1;
let fallInterval = 1000;
let gameLoop;
let isGameOver = false;
let isPaused = false;
let resizeTimer;
let touchStartX = 0;
let touchStartY = 0;
let touchStartTime = 0;
let lastMoveX = 0;
let isDraggingDown = false;
let lastTap = 0;
function updateStaticUIText() {
document.title = lang.title;
document.getElementById('score-label').textContent = lang.score;
document.getElementById('level-label').textContent = lang.level;
document.getElementById('next-label').textContent = lang.next;
document.getElementById('highscore-title').textContent = lang.highscoreTitle;
gameContainer.dataset.pauseText = lang.pauseOverlay;
}
function setGameScale() {
const viewportWidth = window.innerWidth;
const viewportHeight = window.innerHeight;
const headerHeightInBlocks = 3;
const worldAspectRatio = BOARD_WIDTH / (BOARD_HEIGHT + headerHeightInBlocks);
let worldWidth = viewportWidth;
let worldHeight = worldWidth / worldAspectRatio;
if (worldHeight > viewportHeight) {
worldHeight = viewportHeight;
worldWidth = worldHeight * worldAspectRatio;
}
gameWorld.style.width = `${worldWidth}px`;
gameWorld.style.height = `${worldHeight}px`;
blockSize = Math.floor(worldWidth / BOARD_WIDTH);
gameWorld.style.fontSize = `${blockSize * 0.4}px`;
gameCanvas.width = blockSize * BOARD_WIDTH;
gameCanvas.height = blockSize * BOARD_HEIGHT;
const nextCanvas = document.getElementById('nextPieceCanvas');
nextPieceCanvas.width = nextCanvas.clientWidth;
nextPieceCanvas.height = nextCanvas.clientHeight;
previewBlockSize = Math.floor(nextCanvas.clientWidth / 4);
}
function initializeGame() {
board = Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(0));
score = 0;
level = 1;
fallInterval = 1000;
isGameOver = false;
isPaused = false;
gameContainer.classList.remove('paused');
scoreDisplay.textContent = score;
levelDisplay.textContent = level;
gameStatusScreen.style.display = 'none';
}
function showStartScreen() {
statusMessage.textContent = lang.welcome;
statusButton.textContent = lang.startGame;
gameStatusScreen.style.display = 'flex';
finalScoreDisplay.textContent = '';
document.querySelector('.game-over-highscores').style.display = 'none';
instructions.innerHTML = `
<h3>${lang.instructionsTitle}</h3>
<ul>
<li>${lang.insMove}</li>
<li>${lang.insRotate}</li>
<li>${lang.insDrop}</li>
<li>${lang.insDropBonus}</li>
</ul>
`;
instructions.style.display = 'block';
}
function createPiece() {
const typeId = Math.floor(Math.random() * TETROMINOES.length);
const shape = TETROMINOES[typeId];
return {
shape: shape,
x: Math.floor(BOARD_WIDTH / 2) - Math.floor(shape[0].length / 2),
y: 0,
type: typeId,
};
}
function isValidMove(piece, offsetX, offsetY, shape) {
const shapeToCheck = shape || piece.shape;
for (let row = 0; row < shapeToCheck.length; row++) {
for (let col = 0; col < shapeToCheck[row].length; col++) {
if (shapeToCheck[row][col]) {
const newX = piece.x + col + offsetX;
const newY = piece.y + row + offsetY;
if (newX < 0 || newX >= BOARD_WIDTH || newY >= BOARD_HEIGHT) return false;
if (newY < 0) continue;
if (board[newY][newX] > 0) return false;
}
}
}
return true;
}
function rotate(piece) {
const originalShape = piece.shape;
const newShape = originalShape[0].map((_, colIndex) =>
originalShape.map((row) => row[colIndex]).reverse()
);
if (isValidMove(piece, 0, 0, newShape)) {
piece.shape = newShape;
return;
}
const kicks = [
[-1, 0],
[1, 0],
[0, -1],
[-1, -1],
[1, -1]
];
for (const [kx, ky] of kicks) {
if (isValidMove(piece, kx, ky, newShape)) {
piece.shape = newShape;
piece.x += kx;
piece.y += ky;
return;
}
}
}
function freezePiece() {
for (let row = 0; row < currentPiece.shape.length; row++) {
for (let col = 0; col < currentPiece.shape[row].length; col++) {
if (currentPiece.shape[row][col]) {
if (currentPiece.y + row < 0) {
endGame();
return;
}
board[currentPiece.y + row][currentPiece.x + col] = currentPiece.type + 1;
}
}
}
}
function clearRows() {
let rowsCleared = 0;
for (let row = BOARD_HEIGHT - 1; row >= 0; row--) {
if (board[row].every((cell) => cell > 0)) {
rowsCleared++;
board.splice(row, 1);
board.unshift(Array(BOARD_WIDTH).fill(0));
row++;
}
}
if (rowsCleared > 0) {
updateScore(rowsCleared);
}
}
function dropPiece() {
if (isGameOver || isPaused) return;
if (isValidMove(currentPiece, 0, 1)) {
currentPiece.y++;
} else {
freezePiece();
clearRows();
if (!isGameOver) {
currentPiece = nextPiece;
nextPiece = createPiece();
drawNextPiece();
if (!isValidMove(currentPiece, 0, 0)) {
endGame();
}
}
}
drawGame();
}
function gameLoopTick() {
dropPiece();
}
function updateScore(lines) {
const pointsPerLine = [0, 100, 300, 500, 800];
score += pointsPerLine[lines] * level;
scoreDisplay.textContent = score;
updateLevel();
}
function updateLevel() {
const pointsForNextLevel = 3000;
const newLevel = Math.floor(score / pointsForNextLevel) + 1;
if (newLevel > level) {
level = newLevel;
levelDisplay.textContent = level;
const speedIncrease = 40;
const maxSpeed = 250;
fallInterval = Math.max(maxSpeed, fallInterval - speedIncrease);
clearInterval(gameLoop);
gameLoop = setInterval(gameLoopTick, fallInterval);
}
}
function getHighscores() {
const scores = localStorage.getItem(HIGHSCORE_KEY);
return scores ? JSON.parse(scores) : [];
}
function saveHighscores(scores) {
localStorage.setItem(HIGHSCORE_KEY, JSON.stringify(scores));
}
function addHighscore(newScore) {
if (newScore === 0) return;
const scores = getHighscores();
scores.push(newScore);
scores.sort((a, b) => b - a);
const top10Scores = scores.slice(0, 10);
saveHighscores(top10Scores);
}
function displayHighscores() {
const scores = getHighscores();
highscoreList.innerHTML = '';
if (scores.length === 0) {
const li = document.createElement('li');
li.textContent = lang.noHighscores;
highscoreList.appendChild(li);
} else {
scores.slice(0, 3).forEach((score, index) => {
const li = document.createElement('li');
li.textContent = `${index + 1}. ${score}`;
highscoreList.appendChild(li);
});
}
}
function drawBlock(x, y, typeId, context, currentBlockSize, isShadow = false) {
context.save();
const color = COLORS[typeId];
const px = x * currentBlockSize;
const py = y * currentBlockSize;
if (isShadow) {
context.globalAlpha = 0.3;
context.strokeStyle = color;
context.lineWidth = 2;
context.strokeRect(px, py, currentBlockSize, currentBlockSize);
} else {
context.fillStyle = color;
context.shadowColor = color;
context.shadowBlur = 8;
context.fillRect(px, py, currentBlockSize, currentBlockSize);
context.strokeStyle = 'rgba(255, 255, 255, 0.2)';
context.lineWidth = 1;
context.strokeRect(px, py, currentBlockSize, currentBlockSize);
}
context.restore();
}
function findShadowPosition(piece) {
let y = piece.y;
while (isValidMove(piece, 0, y - piece.y + 1)) {
y++;
}
return y;
}
function drawPiece(piece, context, currentBlockSize, isShadow = false) {
const shape = piece.shape;
for (let row = 0; row < shape.length; row++) {
for (let col = 0; col < shape[row].length; col++) {
if (shape[row][col]) {
drawBlock(piece.x + col, piece.y + row, piece.type, context, currentBlockSize, isShadow);
}
}
}
}
function drawBoard() {
for (let row = 0; row < BOARD_HEIGHT; row++) {
for (let col = 0; col < BOARD_WIDTH; col++) {
if (board[row][col] > 0) {
const typeId = board[row][col] - 1;
drawBlock(col, row, typeId, ctx, blockSize);
}
}
}
}
function drawGame() {
ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
drawBoard();
if (currentPiece) {
const shadowY = findShadowPosition(currentPiece);
drawPiece({
...currentPiece,
y: shadowY
}, ctx, blockSize, true);
drawPiece(currentPiece, ctx, blockSize, false);
}
}
function drawNextPiece() {
nextPieceCtx.clearRect(0, 0, nextPieceCanvas.width, nextPieceCanvas.height);
if (nextPiece) {
const shape = nextPiece.shape;
const pieceWidth = shape[0].length * previewBlockSize;
const pieceHeight = shape.length * previewBlockSize;
const startX = (nextPieceCanvas.width - pieceWidth) / 2;
const startY = (nextPieceCanvas.height - pieceHeight) / 2;
const previewPiece = {
...nextPiece,
x: startX / previewBlockSize,
y: startY / previewBlockSize,
};
drawPiece(previewPiece, nextPieceCtx, previewBlockSize);
}
}
function restartGame() {
initializeGame();
currentPiece = createPiece();
nextPiece = createPiece();
drawNextPiece();
drawGame();
if (gameLoop) clearInterval(gameLoop);
gameLoop = setInterval(gameLoopTick, fallInterval);
}
function endGame() {
isGameOver = true;
clearInterval(gameLoop);
statusMessage.textContent = lang.gameOver;
finalScoreDisplay.textContent = lang.yourScore + score;
statusButton.textContent = lang.playAgain;
gameStatusScreen.style.display = 'flex';
instructions.style.display = 'none';
document.querySelector('.game-over-highscores').style.display = 'block';
addHighscore(score);
displayHighscores();
}
function togglePause() {
if (isGameOver) return;
isPaused = !isPaused;
if (isPaused) {
clearInterval(gameLoop);
gameContainer.classList.add('paused');
} else {
gameLoop = setInterval(gameLoopTick, fallInterval);
gameContainer.classList.remove('paused');
}
}
function handleTouchStart(e) {
const currentTime = new Date().getTime();
const tapLength = currentTime - lastTap;
if (tapLength < 300 && tapLength > 0) {
e.preventDefault();
}
lastTap = currentTime;
if (isGameOver || isPaused) return;
const touch = e.touches[0];
touchStartX = touch.clientX;
touchStartY = touch.clientY;
touchStartTime = new Date().getTime();
lastMoveX = touch.clientX;
isDraggingDown = false;
}
function handleTouchMove(e) {
if (isGameOver || isPaused || !currentPiece) return;
e.preventDefault();
const touch = e.touches[0];
const deltaX = touch.clientX - touchStartX;
const deltaY = touch.clientY - touchStartY;
const moveThreshold = blockSize * 0.8;
const horizontalMove = touch.clientX - lastMoveX;
if (!isDraggingDown && deltaY > blockSize / 2 && Math.abs(deltaY) > Math.abs(deltaX)) {
isDraggingDown = true;
}
if (!isDraggingDown && Math.abs(horizontalMove) > moveThreshold) {
if (horizontalMove > 0) {
if (isValidMove(currentPiece, 1, 0)) currentPiece.x++;
} else {
if (isValidMove(currentPiece, -1, 0)) currentPiece.x--;
}
lastMoveX = touch.clientX;
drawGame();
}
if (deltaY > blockSize) {
if (isValidMove(currentPiece, 0, 1)) {
currentPiece.y++;
score++;
scoreDisplay.textContent = score;
drawGame();
touchStartY = touch.clientY;
}
}
}
function handleTouchEnd(e) {
if (isGameOver || isPaused || !currentPiece) return;
const touchEndTime = new Date().getTime();
const touchDuration = touchEndTime - touchStartTime;
const touch = e.changedTouches[0];
const deltaX = touch.clientX - touchStartX;
const deltaY = touch.clientY - touchStartY;
const tapThreshold = blockSize;
if (touchDuration < 200 && Math.abs(deltaX) < tapThreshold && Math.abs(deltaY) < tapThreshold) {
rotate(currentPiece);
drawGame();
}
}
function onWindowResize() {
setGameScale();
drawGame();
drawNextPiece();
}
gameCanvas.addEventListener('touchstart', handleTouchStart, {
passive: false
});
gameCanvas.addEventListener('touchmove', handleTouchMove, {
passive: false
});
gameCanvas.addEventListener('touchend', handleTouchEnd);
statusButton.addEventListener('click', restartGame);
pauseButton.addEventListener('click', togglePause);
window.addEventListener('resize', () => {
clearTimeout(resizeTimer);
resizeTimer = setTimeout(onWindowResize, 150);
});
document.addEventListener('gesturestart', function(e) {
e.preventDefault();
});
document.addEventListener('dblclick', function(e) {
e.preventDefault();
}, {
passive: false
});
function init() {
updateStaticUIText();
setGameScale();
showStartScreen();
}
init();
</script>
</body>
</html>
