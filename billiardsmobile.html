<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Billiards Mobile</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text x=%2250%22 y=%2275%22 font-size=%2280%22 text-anchor=%22middle%22>%F0%9F%8E%B1</text></svg>">
<style>
:root {
--table-felt: #008080;
--table-rail: #8d6e63;
--background-start: #2a5298;
--background-end: #1e3c72;
--text-color: #ffffff;
--shadow-color: rgba(0, 0, 0, 0.3);
--button-bg: #ff6d00;
--button-hover-bg: #ff8124;
}
html,
body {
margin: 0;
padding: 0;
width: 100%;
height: 100svh;
overflow: hidden;
background: linear-gradient(to top, var(--background-start), var(--background-end));
background-color: #2a5298;
display: flex;
justify-content: center;
align-items: center;
font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
color: var(--text-color);
}
#game-area {
display: flex;
flex-direction: row;
align-items: center;
justify-content: center;
width: 100%;
height: 100svh;
position: relative;
gap: 5px;
padding: 5px;
box-sizing: border-box;
}
#top-ui {
display: flex;
flex-direction: column;
justify-content: space-around;
align-items: center;
width: 90px;
height: 100%;
max-height: 500px;
flex-shrink: 0;
box-sizing: border-box;
gap: 10px;
}
.pocketed-balls-area {
width: 100%;
min-height: 40px;
background: rgba(0, 0, 0, 0.2);
border-radius: 8px;
padding: 5px;
box-sizing: border-box;
transition: all 0.3s ease;
flex-grow: 1;
display: flex;
flex-direction: column;
}
.pocketed-balls-area h3 {
margin: 0 0 5px 0;
font-size: clamp(0.7rem, 2.5vw, 0.8rem);
text-align: center;
flex-shrink: 0;
}
.pocketed-balls-container {
display: flex;
flex-wrap: wrap;
gap: 4px;
min-height: 20px;
justify-content: center;
align-content: flex-start;
flex-grow: 1;
}
.pocketed-ball-display {
width: 12px;
height: 12px;
border-radius: 50%;
background-color: white;
box-shadow: inset 1px 1px 3px rgba(0, 0, 0, 0.5);
}
.pocketed-ball-display.stripe {
background-image: repeating-linear-gradient(-45deg,
white,
white 5px,
var(--stripe-color) 5px,
var(--stripe-color) 10px);
}
#header {
text-align: center;
color: var(--text-color);
text-shadow: 0 2px 4px var(--shadow-color);
flex-shrink: 0;
width: 100%;
position: relative;
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
}
#game-over-container {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
z-index: 100;
display: none;
flex-direction: column;
align-items: center;
justify-content: center;
background-color: rgba(0, 0, 0, 0.5);
padding: 20px;
border-radius: 15px;
}
#game-over-message {
font-size: clamp(1.1rem, 3vw, 1.3rem);
font-weight: bold;
color: var(--text-color);
text-shadow: 0 2px 4px var(--shadow-color);
margin: 0 0 15px 0;
text-align: center;
}
#main-content {
display: flex;
flex-grow: 1;
align-items: center;
justify-content: center;
padding: 0;
box-sizing: border-box;
min-height: 0;
height: 100%;
min-width: 0;
}
#canvas-container {
background: transparent;
padding: 0;
box-shadow: none;
flex-grow: 1;
height: 100%;
display: flex;
align-items: center;
justify-content: center;
min-width: 0;
min-height: 0;
}
#table-rail-wrapper {
position: relative;
background: var(--table-rail);
padding: 18px;
border-radius: 24px;
box-shadow: 0 20px 50px var(--shadow-color);
display: flex;
flex-shrink: 0;
}
canvas {
display: block;
background: var(--table-felt);
border-radius: 6px;
max-width: 100%;
max-height: 100%;
cursor: grab;
box-shadow: inset 0 0 12px rgba(0, 0, 0, 0.6);
}
canvas:active {
cursor: grabbing;
}
#power-slider-container {
width: 60px;
height: 80%;
flex-shrink: 0;
display: flex;
justify-content: center;
align-items: center;
padding-left: 15px;
box-sizing: border-box;
}
#power-slider {
position: relative;
width: 30px;
height: 100%;
background-color: rgba(0, 0, 0, 0.3);
border-radius: 20px;
cursor: pointer;
touch-action: none;
border: 2px solid rgba(255, 255, 255, 0.2);
}
#power-level {
position: absolute;
bottom: 0;
width: 100%;
height: 0%;
background: linear-gradient(to top, #ffca28, #ff6d00, #d50000);
border-radius: 20px;
}
.game-button {
background-color: var(--button-bg);
color: var(--text-color);
border: none;
border-radius: 8px;
padding: 10px 20px;
font-size: clamp(1rem, 2.5vw, 1.2rem);
font-weight: bold;
cursor: pointer;
box-shadow: 0 4px 15px var(--shadow-color);
transition: all 0.2s ease-in-out;
}
.game-button:hover {
background-color: var(--button-hover-bg);
transform: translateY(-2px);
}
#play-again-btn {
flex-shrink: 0;
}
#how-to-play-btn {
padding: 5px 10px;
font-size: clamp(0.7rem, 2vw, 0.8rem);
margin-bottom: 2px;
}
#rules-modal {
display: none;
position: fixed;
z-index: 200;
left: 0;
top: 0;
width: 100%;
height: 100%;
overflow: auto;
background-color: rgba(0, 0, 0, 0.6);
align-items: center;
justify-content: center;
padding: 10px;
box-sizing: border-box;
}
.modal-content {
background: linear-gradient(to bottom, var(--background-start), var(--background-end));
margin: 0 auto;
padding: 15px;
border: 1px solid var(--table-rail);
border-radius: 10px;
width: 100%;
max-width: 500px;
position: relative;
max-height: 90%;
overflow-y: auto;
}
.modal-content h2 {
margin-top: 0;
color: var(--button-bg);
}
.modal-content p,
.modal-content li {
line-height: 1.4;
font-size: clamp(0.8rem, 2.5vw, 0.9rem);
}
.close-btn {
color: #aaa;
position: absolute;
top: 10px;
right: 25px;
font-size: 35px;
font-weight: bold;
cursor: pointer;
}
.close-btn:hover,
.close-btn:focus {
color: white;
}
</style>
</head>
<body>
<div id="rules-modal">
<div class="modal-content">
<span class="close-btn">&times;</span>
<p><strong>Objective:</strong> Be the first player to pocket all of your assigned balls (solids or stripes) and then legally pocket the 8-ball.</p>
<h3>Controls</h3>
<p>
<strong>Aim:</strong> Drag your finger anywhere on the pool table to aim the cue stick.
<br>
<strong>Shoot:</strong> Use the vertical power bar on the right. Drag the handle down to set the power and release to shoot.
</p>
<h3>Gameplay</h3>
<ul>
<li><strong>Assigning Groups:</strong> The table is "open" at the start. The first player to legally pocket a ball will be assigned that ball's group (e.g., pocket a solid-colored ball to become solids).</li>
<li><strong>Turns:</strong> You continue your turn as long as you legally pocket one of your own balls.</li>
<li>
<strong>Fouls:</strong> If you commit a foul, your turn ends, and the opponent gets "ball in hand." Fouls include:
<ul>
<li>Pocketing the cue ball (a "scratch").</li>
<li>Hitting an opponent's ball or the 8-ball before your own.</li>
<li>Failing to hit any ball with the cue ball.</li>
<li>After contact, if no ball is pocketed, some ball (any ball) must hit a rail.</li>
</ul>
</li>
<li><strong>Ball in Hand:</strong> After a foul, the opponent can place the cue ball anywhere on the table by dragging it. Lift your finger to place it. If the foul occurs on the break shot, placement must be behind the head string (the first quarter of the table).</li>
<li><strong>Winning/Losing:</strong> You win by pocketing the 8-ball after all of your other balls are gone. You lose if you pocket the 8-ball too early or commit a foul (like a scratch) on the final 8-ball shot.</li>
</ul>
</div>
</div>
<div id="game-area">
<div id="top-ui">
<div id="player-pocketed-area" class="pocketed-balls-area">
<h3>Player</h3>
<div id="player-pocketed-container" class="pocketed-balls-container"></div>
</div>
<div id="header">
<button id="how-to-play-btn" class="game-button">Help</button>
</div>
<div id="ai-pocketed-area" class="pocketed-balls-area">
<h3>AI</h3>
<div id="ai-pocketed-container" class="pocketed-balls-container"></div>
</div>
</div>
<div id="main-content">
<div id="canvas-container">
<div id="table-rail-wrapper">
<canvas id="pool-canvas"></canvas>
</div>
</div>
<div id="power-slider-container">
<div id="power-slider">
<div id="power-level"></div>
</div>
</div>
</div>
<div id="game-over-container">
<p id="game-over-message"></p>
<button id="play-again-btn" class="game-button">Play Again</button>
</div>
</div>
<script>
window.addEventListener('load', () => {
const canvas = document.getElementById('pool-canvas');
const ctx = canvas.getContext('2d');
const playerPocketedContainer = document.getElementById('player-pocketed-container');
const aiPocketedContainer = document.getElementById('ai-pocketed-container');
const gameOverContainer = document.getElementById('game-over-container');
const gameOverMessage = document.getElementById('game-over-message');
const playAgainBtn = document.getElementById('play-again-btn');
const rulesModal = document.getElementById('rules-modal');
const howToPlayBtn = document.getElementById('how-to-play-btn');
const closeModalBtn = document.querySelector('.close-btn');
const Sound = {
audioCtx: null,
masterVolume: null,
init() {
const createContextOnce = () => {
if (this.audioCtx) return;
try {
this.audioCtx = new(window.AudioContext || window.webkitAudioContext)();
this.masterVolume = this.audioCtx.createGain();
this.masterVolume.gain.setValueAtTime(0.5, this.audioCtx.currentTime);
this.masterVolume.connect(this.audioCtx.destination);
} catch (e) {
console.error("Web Audio API is not supported in this browser");
}
};
const addListener = (event) => {
canvas.addEventListener(event, createContextOnce, {
once: true,
passive: true
});
};
addListener('mousedown');
addListener('touchstart');
},
_playTone(freq, type, vol, duration, attack = 0.01, decay = 0.1, freqSweep = 0) {
if (!this.audioCtx) return;
const t = this.audioCtx.currentTime;
const osc = this.audioCtx.createOscillator();
const gain = this.audioCtx.createGain();
osc.type = type;
osc.frequency.setValueAtTime(freq, t);
if (freqSweep !== 0) {
osc.frequency.exponentialRampToValueAtTime(freq + freqSweep, t + duration);
}
gain.gain.setValueAtTime(0, t);
gain.gain.linearRampToValueAtTime(vol, t + attack);
gain.gain.exponentialRampToValueAtTime(0.001, t + duration);
osc.connect(gain);
gain.connect(this.masterVolume);
osc.start(t);
osc.stop(t + duration);
},
playShot(volume) {
const vol = Math.min(1, Math.max(0, volume)) * 0.8;
this._playTone(2500, 'sine', vol, 0.03, 0.001, 0.02, -1500);
},
playBallCollision(volume) {
const vol = Math.min(1, Math.max(0, volume)) * 0.6;
if (vol < 0.05) return;
this._playTone(2500, 'sine', vol, 0.03, 0.001, 0.02, -1500);
},
playRailHit(volume) {
const vol = Math.min(1, Math.max(0, volume)) * 0.5;
if (vol < 0.05) return;
this._playTone(440, 'sine', vol, 0.15, 0.01, 0.1, -100);
},
playPocket() {
this._playTone(220, 'sine', 0.7, 0.3, 0.01, 0.2, -50);
},
playWin() {
this._playTone(523.25, 'sine', 0.4, 0.15, 0.01, 0.1);
setTimeout(() => this._playTone(659.25, 'sine', 0.4, 0.15, 0.01, 0.1), 150);
setTimeout(() => this._playTone(783.99, 'sine', 0.4, 0.15, 0.01, 0.1), 300);
setTimeout(() => this._playTone(1046.50, 'sine', 0.5, 0.3, 0.01, 0.2), 450);
},
playLose() {
this._playTone(440, 'sawtooth', 0.3, 0.2, 0.01, 0.15, -100);
setTimeout(() => this._playTone(330, 'sawtooth', 0.3, 0.3, 0.01, 0.25, -100), 200);
},
playClick() {
const vol = 0.3;
this._playTone(2500, 'sine', vol, 0.03, 0.001, 0.02, -1500);
}
};
let balls = [],
pockets = [];
const player = {
name: 'Player',
ballType: null
};
const ai = {
name: 'AI',
ballType: null
};
let gameState = 'LOADING';
class Vector {
constructor(x = 0, y = 0) {
this.x = x;
this.y = y;
}
add(v) {
return new Vector(this.x + v.x, this.y + v.y);
}
subtract(v) {
return new Vector(this.x - v.x, this.y - v.y);
}
multiply(s) {
return new Vector(this.x * s, this.y * s);
}
magnitude() {
return Math.sqrt(this.x ** 2 + this.y ** 2);
}
normalize() {
const m = this.magnitude();
return m > 0 ? new Vector(this.x / m, this.y / m) : new Vector();
}
dot(v) {
return this.x * v.x + this.y * v.y;
}
}
class Ball {
constructor(pos, number) {
this.pos = pos;
this.vel = new Vector();
this.number = number;
this.radius = 0;
this.isSunk = false;
this.hitRail = false;
if (number === 0) this.type = 'cue';
else if (number === 8) this.type = '8ball';
else if (number > 0 && number < 8) this.type = 'solid';
else if (number > 8 && number <= 15) this.type = 'stripe';
else this.type = 'invalid';
this.baseColor = this.getColor();
this.displayColor = this.baseColor;
}
getColor() {
const colors = {
0: '#ffffff',
1: '#ffca28',
2: '#2962ff',
3: '#d50000',
4: '#6200ea',
5: '#ff6d00',
6: '#00c853',
7: '#c51162',
8: '#212121',
9: '#ffca28',
10: '#2962ff',
11: '#d50000',
12: '#6200ea',
13: '#ff6d00',
14: '#00c853',
15: '#c51162'
};
return colors[this.number] || '#ff00ff';
}
draw() {
if (this.isSunk || this.type === 'invalid') return;
ctx.save();
ctx.shadowColor = 'rgba(0,0,0,0.3)';
ctx.shadowBlur = this.radius * 0.3;
ctx.shadowOffsetX = this.radius * 0.1;
ctx.shadowOffsetY = this.radius * 0.2;
ctx.beginPath();
ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
ctx.fillStyle = this.displayColor;
if (this.type === 'cue' && gameState === 'BALL_IN_HAND' && Game.currentPlayer === player) {
ctx.globalAlpha = 0.7;
}
ctx.fill();
ctx.globalAlpha = 1;
if (this.type === 'stripe') {
ctx.fillStyle = 'white';
ctx.save();
ctx.clip();
ctx.fillRect(this.pos.x - this.radius, this.pos.y - this.radius * 0.5, this.radius * 2, this.radius);
ctx.restore();
}
let shadeGradient = ctx.createRadialGradient(this.pos.x, this.pos.y, this.radius * 0.1, this.pos.x, this.pos.y, this.radius);
shadeGradient.addColorStop(0, 'rgba(0,0,0,0.05)');
shadeGradient.addColorStop(0.7, 'rgba(0,0,0,0.3)');
shadeGradient.addColorStop(1, 'rgba(0,0,0,0.5)');
ctx.fillStyle = shadeGradient;
ctx.fill();
let highlightGradient = ctx.createRadialGradient(this.pos.x - this.radius * 0.4, this.pos.y - this.radius * 0.5, this.radius * 0.05, this.pos.x, this.pos.y, this.radius);
highlightGradient.addColorStop(0, 'rgba(255,255,255,0.7)');
highlightGradient.addColorStop(0.3, 'rgba(255,255,255,0)');
ctx.fillStyle = highlightGradient;
ctx.fill();
ctx.restore();
}
}
class Pocket {
constructor(pos, isCorner) {
this.pos = pos;
this.isCorner = isCorner;
this.radius = 0;
}
draw() {
ctx.beginPath();
ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
ctx.fillStyle = 'rgba(0,0,0,0.5)';
ctx.fill();
}
}
const Physics = {
shotData: {},
update(deltaTime) {
if (!deltaTime || deltaTime <= 0) return;
const timeCorrection = deltaTime * 60;
const iterations = 5;
for (let iter = 0; iter < iterations; iter++) {
balls.forEach(b => {
if (!b.isSunk) b.pos = b.pos.add(b.vel.multiply(timeCorrection / iterations));
});
this.handleCollisions();
}
balls.forEach(b => {
const friction = Math.pow(0.985, timeCorrection);
b.vel = b.vel.multiply(friction);
if (b.vel.magnitude() < 0.02) b.vel = new Vector();
});
},
handleCollisions() {
for (let i = 0; i < balls.length; i++) {
for (let j = i + 1; j < balls.length; j++) {
const b1 = balls[i];
const b2 = balls[j];
if (b1.isSunk || b2.isSunk) continue;
const distVec = b1.pos.subtract(b2.pos);
const dist = distVec.magnitude();
if (dist < b1.radius + b2.radius) {
if ((b1.type === 'cue' || b2.type === 'cue') && !this.shotData.firstHit) {
this.shotData.firstHit = (b1.type === 'cue') ? b2 : b1;
}
const normal = distVec.normalize();
const overlap = b1.radius + b2.radius - dist;
b1.pos = b1.pos.add(normal.multiply(overlap / 2));
b2.pos = b2.pos.subtract(normal.multiply(overlap / 2));
const tangent = new Vector(-normal.y, normal.x);
const v1n = b1.vel.dot(normal);
const v1t = b1.vel.dot(tangent);
const v2n = b2.vel.dot(normal);
const v2t = b2.vel.dot(tangent);
Sound.playBallCollision(Math.abs(v1n - v2n) / 25);
const v1nFinal = v2n;
const v2nFinal = v1n;
const v1nVec = normal.multiply(v1nFinal);
const v1tVec = tangent.multiply(v1t);
const v2nVec = normal.multiply(v2nFinal);
const v2tVec = tangent.multiply(v2t);
b1.vel = v1nVec.add(v1tVec);
b2.vel = v2nVec.add(v2tVec);
}
}
}
balls.forEach(b => {
if (b.isSunk) return;
pockets.forEach(p => {
if (b.pos.subtract(p.pos).magnitude() < p.radius) {
b.isSunk = true;
b.vel = new Vector();
this.shotData.sunkBalls.push(b);
Sound.playPocket();
}
});
if (b.isSunk) return;
const railRestitution = -0.85;
if ((b.pos.x < b.radius) || (b.pos.x > canvas.width - b.radius)) {
Sound.playRailHit(Math.abs(b.vel.x) / 20);
b.pos.x = (b.pos.x < b.radius) ? b.radius : canvas.width - b.radius;
b.vel.x *= railRestitution;
if (!b.hitRail) {
this.shotData.hitRailAfterContact = true;
b.hitRail = true;
}
}
if ((b.pos.y < b.radius) || (b.pos.y > canvas.height - b.radius)) {
Sound.playRailHit(Math.abs(b.vel.y) / 20);
b.pos.y = (b.pos.y < b.radius) ? b.radius : canvas.height - b.radius;
b.vel.y *= railRestitution;
if (!b.hitRail) {
this.shotData.hitRailAfterContact = true;
b.hitRail = true;
}
}
});
},
isMoving() {
return balls.some(b => !b.isSunk && b.vel.magnitude() > 0.02);
}
};
const Game = {
currentPlayer: player,
isTableOpen: true,
isBreakShot: true,
animationFrame: null,
lastTime: 0,
initializeTable() {
const w = canvas.width,
h = canvas.height;
const ballRadius = w / 48;
pockets = [];
const cornerPocketMargin = ballRadius * 0.5;
const sidePocketOffset = ballRadius * 0.2;
pockets.push(
new Pocket(new Vector(cornerPocketMargin, cornerPocketMargin), true),
new Pocket(new Vector(w / 2, -sidePocketOffset), false),
new Pocket(new Vector(w - cornerPocketMargin, cornerPocketMargin), true),
new Pocket(new Vector(cornerPocketMargin, h - cornerPocketMargin), true),
new Pocket(new Vector(w / 2, h + sidePocketOffset), false),
new Pocket(new Vector(w - cornerPocketMargin, h - cornerPocketMargin), true)
);
pockets.forEach(p => {
p.radius = p.isCorner ? ballRadius * 1.6 : ballRadius * 1.7;
});
balls = [];
balls.push(new Ball(new Vector(w / 4, h / 2), 0));
const shuffleArray = a => {
for (let i = a.length - 1; i > 0; i--) {
const j = Math.floor(Math.random() * (i + 1));
[a[i], a[j]] = [a[j], a[i]];
}
};
let numberedBalls = Array.from({
length: 15
}, (_, i) => i + 1).filter(n => n !== 8);
shuffleArray(numberedBalls);
const solids = numberedBalls.filter(n => n < 8);
const stripes = numberedBalls.filter(n => n > 8);
const finalRack = new Array(15);
finalRack[4] = 8;
finalRack[10] = solids.pop();
finalRack[14] = stripes.pop();
const remainingNumbers = [...solids, ...stripes];
shuffleArray(remainingNumbers);
for (let i = 0, numIdx = 0; i < 15; i++) {
if (typeof finalRack[i] === 'undefined') {
finalRack[i] = remainingNumbers[numIdx++];
}
}
let idx = 0;
const startX = w * 0.7;
const squeezeFactor = 0.998;
for (let i = 0; i < 5; i++) {
for (let j = 0; j <= i; j++) {
const num = finalRack[idx++];
if (typeof num === 'undefined') continue;
const x = startX + i * (ballRadius * 2 * Math.sqrt(3) / 2 * squeezeFactor);
const y = h / 2 + j * (ballRadius * 2 * squeezeFactor) - i * (ballRadius * squeezeFactor);
balls.push(new Ball(new Vector(x, y), num));
}
}
balls.forEach(b => {
b.radius = ballRadius;
b.isSunk = false;
b.vel = new Vector();
});
},
startNewGame() {
gameOverContainer.style.display = 'none';
player.ballType = null;
ai.ballType = null;
this.currentPlayer = player;
this.isTableOpen = true;
this.isBreakShot = true;
this.initializeTable();
this.updatePocketedDisplay();
gameState = 'AWAITING_INPUT';
if (!this.animationFrame) {
this.lastTime = 0;
this.animationFrame = requestAnimationFrame(t => this.loop(t));
}
},
loop(currentTime) {
if (gameState === 'GAME_OVER') {
this.animationFrame = null;
return;
}
if (!this.lastTime) this.lastTime = currentTime;
const deltaTime = Math.min((currentTime - this.lastTime) / 1000, 1 / 30);
this.lastTime = currentTime;
if (gameState === 'SHOT_IN_PROGRESS') Physics.update(deltaTime);
this.draw();
if (gameState === 'SHOT_IN_PROGRESS' && !Physics.isMoving()) {
this.evaluateTurn();
}
this.animationFrame = requestAnimationFrame(t => this.loop(t));
},
draw() {
ctx.clearRect(0, 0, canvas.width, canvas.height);
if ((gameState === 'BALL_IN_HAND' || gameState === 'AWAITING_INPUT') && this.isBreakShot) {
ctx.save();
ctx.beginPath();
ctx.moveTo(canvas.width / 4, 0);
ctx.lineTo(canvas.width / 4, canvas.height);
ctx.setLineDash([5, 10]);
ctx.strokeStyle = 'rgba(255,255,255,0.4)';
ctx.lineWidth = 1;
ctx.stroke();
ctx.restore();
}
pockets.forEach(p => p.draw());
balls.forEach(b => b.draw());
Input.drawAimLine();
},
evaluateTurn() {
const {
firstHit,
sunkBalls,
hitRailAfterContact
} = Physics.shotData;
const sunk8Ball = sunkBalls.some(b => b.type === '8ball');
const sunkCueBall = sunkBalls.some(b => b.type === 'cue');
let foul = false;
if (sunkCueBall) foul = true;
else if (!firstHit) foul = true;
else if (this.isTableOpen) {
if (firstHit.type === '8ball') foul = true;
} else {
const remainingTargetBalls = balls.filter(b => b.type === this.currentPlayer.ballType && !b.isSunk).length;
if (firstHit.type === '8ball' && remainingTargetBalls > 0) foul = true;
else if (firstHit.type !== this.currentPlayer.ballType && firstHit.type !== '8ball') foul = true;
}
if (sunkBalls.length === 0 && firstHit && !hitRailAfterContact) foul = true;
if (sunk8Ball) {
const remaining = balls.filter(b => b.type === this.currentPlayer.ballType && !b.isSunk).length;
if (foul || this.isTableOpen || (remaining > 0 && !this.isBreakShot)) {
this.endGame(this.getOpponent(), `wins because ${this.currentPlayer.name} illegally pocketed the 8-ball`);
} else {
this.endGame(this.currentPlayer, 'wins');
}
return;
}
if (foul) {
this.handleFoul(this.isBreakShot);
return;
}
let legalPot = false;
const targetSunkBalls = sunkBalls.filter(b => b.type === 'solid' || b.type === 'stripe');
if (this.isTableOpen && targetSunkBalls.length > 0) {
const firstSunkType = targetSunkBalls[0].type;
this.currentPlayer.ballType = firstSunkType;
this.getOpponent().ballType = firstSunkType === 'solid' ? 'stripe' : 'solid';
this.isTableOpen = false;
legalPot = true;
} else if (!this.isTableOpen && sunkBalls.some(b => b.type === this.currentPlayer.ballType)) {
legalPot = true;
}
this.updatePocketedDisplay();
this.isBreakShot = false;
if (legalPot) {
this.continueTurn();
} else {
this.switchTurn(false);
}
},
handleFoul(isBreakFoul) {
const cueBall = balls.find(b => b.type === 'cue');
if (cueBall.isSunk) {
cueBall.isSunk = false;
}
this.switchTurn(true, isBreakFoul);
},
continueTurn() {
gameState = 'AWAITING_INPUT';
if (this.currentPlayer === ai) {
setTimeout(() => AI.takeShot(), 1000);
}
},
switchTurn(isFoul = false, isBreakFoul = false) {
this.currentPlayer = this.getOpponent();
if (isFoul) {
gameState = 'BALL_IN_HAND';
Input.isBreakShotPlacement = isBreakFoul;
if (this.currentPlayer === ai) {
setTimeout(() => AI.placeBall(isBreakFoul), 500);
}
} else {
gameState = 'AWAITING_INPUT';
if (this.currentPlayer === ai) {
setTimeout(() => AI.takeShot(), 1000);
}
}
},
endGame(winner, reason) {
gameState = 'GAME_OVER';
gameOverMessage.textContent = `${winner.name} ${reason}!`;
gameOverContainer.style.display = 'flex';
this.updatePocketedDisplay();
if (winner === player) Sound.playWin();
else Sound.playLose();
},
getOpponent() {
return this.currentPlayer === player ? ai : player;
},
updatePocketedDisplay() {
playerPocketedContainer.innerHTML = '';
aiPocketedContainer.innerHTML = '';
balls.forEach(ball => {
if (ball.isSunk && (ball.type === 'solid' || ball.type === 'stripe')) {
const ballDiv = document.createElement('div');
ballDiv.className = 'pocketed-ball-display';
let ownerContainer = null;
if (player.ballType === ball.type) ownerContainer = playerPocketedContainer;
else if (ai.ballType === ball.type) ownerContainer = aiPocketedContainer;
if (ownerContainer) {
if (ball.type === 'stripe') {
ballDiv.classList.add('stripe');
ballDiv.style.setProperty('--stripe-color', ball.baseColor);
} else {
ballDiv.style.backgroundColor = ball.baseColor;
}
ownerContainer.appendChild(ballDiv);
}
}
});
},
handleResize() {
const canvasContainer = document.getElementById('canvas-container');
const oldWidth = canvas.width;
const oldHeight = canvas.height;
const containerPadding = 10;
const railPadding = 36;
const availableWidth = canvasContainer.clientWidth - containerPadding - railPadding;
const availableHeight = canvasContainer.clientHeight - containerPadding - railPadding;
let tableWidth = availableWidth;
let tableHeight = tableWidth / 2;
if (tableHeight > availableHeight) {
tableHeight = availableHeight;
tableWidth = tableHeight * 2;
}
canvas.width = tableWidth;
canvas.height = tableHeight;
if (balls.length > 0 && pockets.length > 0) {
const w = canvas.width,
h = canvas.height;
const ballRadius = w / 48;
const cornerPocketMargin = ballRadius * 0.5;
const sidePocketOffset = ballRadius * 0.2;
pockets[0].pos = new Vector(cornerPocketMargin, cornerPocketMargin);
pockets[1].pos = new Vector(w / 2, -sidePocketOffset);
pockets[2].pos = new Vector(w - cornerPocketMargin, cornerPocketMargin);
pockets[3].pos = new Vector(cornerPocketMargin, h - cornerPocketMargin);
pockets[4].pos = new Vector(w / 2, h + sidePocketOffset);
pockets[5].pos = new Vector(w - cornerPocketMargin, h - cornerPocketMargin);
pockets.forEach(p => {
p.radius = p.isCorner ? ballRadius * 1.6 : ballRadius * 1.7;
});
balls.forEach(b => {
if (!b.isSunk && oldWidth > 0 && oldHeight > 0) {
b.pos.x = b.pos.x * (w / oldWidth);
b.pos.y = b.pos.y * (h / oldHeight);
}
b.radius = ballRadius;
});
}
this.draw();
}
};
const Input = {
aimDir: new Vector(-1, 0),
power: 0,
isAiming: false,
isSettingPower: false,
isBreakShotPlacement: true,
powerSlider: null,
powerLevel: null,
init() {
this.powerSlider = document.getElementById('power-slider');
this.powerLevel = document.getElementById('power-level');
const addEvt = (target, event, handler, passive = false) => {
target.addEventListener(event, handler, {
passive
});
};
addEvt(window, 'mousedown', e => this.startAim(e));
addEvt(window, 'mousemove', e => this.processMove(e));
addEvt(window, 'mouseup', e => this.endInteraction(e));
addEvt(window, 'touchstart', e => this.startAim(e));
addEvt(window, 'touchmove', e => this.processMove(e));
addEvt(window, 'touchend', e => this.endInteraction(e));
addEvt(this.powerSlider, 'mousedown', e => this.startPower(e));
addEvt(this.powerSlider, 'touchstart', e => this.startPower(e), false);
},
getEventPos(e, targetElement = canvas) {
const rect = targetElement.getBoundingClientRect();
const touch = e.touches ? e.touches[0] : e;
return new Vector(touch.clientX - rect.left, touch.clientY - rect.top);
},
startAim(e) {
if (e.target.closest('button') || e.target.closest('#power-slider-container') || e.target.closest('#rules-modal')) return;
if (gameState === 'BALL_IN_HAND' && Game.currentPlayer === player) {
this.isAiming = true;
return;
}
if (gameState !== 'AWAITING_INPUT' || Game.currentPlayer !== player) return;
this.isAiming = true;
this.doAim(e);
},
doAim(e) {
const cueBall = balls[0];
const eventPos = this.getEventPos(e);
this.aimDir = cueBall.pos.subtract(eventPos).normalize();
},
startPower(e) {
if (gameState !== 'AWAITING_INPUT' || Game.currentPlayer !== player) return;
e.preventDefault();
this.isSettingPower = true;
},
setPower(e) {
const rect = this.powerSlider.getBoundingClientRect();
const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
const powerRatio = 1 - Math.max(0, Math.min(1, y / rect.height));
this.power = powerRatio;
this.powerLevel.style.height = `${this.power * 100}%`;
},
shoot() {
if (this.power < 0.05) {
this.power = 0;
this.powerLevel.style.height = '0%';
return;
}
const cueBall = balls[0];
gameState = 'SHOT_IN_PROGRESS';
Physics.shotData = {
sunkBalls: [],
firstHit: null,
hitRailAfterContact: false
};
balls.forEach(b => (b.hitRail = false));
const maxPower = 40;
Sound.playShot(this.power);
cueBall.vel = this.aimDir.multiply(this.power * maxPower);
this.power = 0;
this.powerLevel.style.transition = 'height 0.3s';
this.powerLevel.style.height = '0%';
setTimeout(() => {
this.powerLevel.style.transition = '';
}, 300);
},
processMove(e) {
if (this.isAiming) {
if (gameState === 'BALL_IN_HAND') this.handleBallInHand(e);
else this.doAim(e);
} else if (this.isSettingPower) {
this.setPower(e);
}
},
endInteraction(e) {
if (this.isAiming) {
this.isAiming = false;
if (gameState === 'BALL_IN_HAND') {
const cueBall = balls[0];
if (cueBall.displayColor === cueBall.baseColor) {
gameState = 'AWAITING_INPUT';
this.isBreakShotPlacement = false;
}
}
} else if (this.isSettingPower) {
this.isSettingPower = false;
this.shoot();
}
},
handleBallInHand(e) {
if (Game.currentPlayer !== player) return;
let newPos = this.getEventPos(e);
const cueBall = balls[0];
const r = cueBall.radius;
const maxX = this.isBreakShotPlacement ? (canvas.width / 4) - r : canvas.width - r;
newPos.x = Math.max(r, Math.min(maxX, newPos.x));
newPos.y = Math.max(r, Math.min(canvas.height - r, newPos.y));
cueBall.pos = newPos;
let overlap = balls.slice(1).some(b => !b.isSunk && cueBall.pos.subtract(b.pos).magnitude() < r * 2);
cueBall.displayColor = overlap ? '#ff4d4d' : cueBall.baseColor;
},
drawAimLine() {
if (gameState !== 'AWAITING_INPUT' || Game.currentPlayer !== player) return;
const cueBall = balls[0];
const aimDir = this.aimDir;
const endPoint = cueBall.pos.add(aimDir.multiply(2000));
ctx.save();
ctx.beginPath();
ctx.moveTo(cueBall.pos.x, cueBall.pos.y);
ctx.lineTo(endPoint.x, endPoint.y);
ctx.setLineDash([3, 8]);
ctx.strokeStyle = 'rgba(255,255,255,0.7)';
ctx.lineWidth = 2;
ctx.stroke();
ctx.restore();
let closestHit = {
dist: Infinity,
ball: null
};
for (const ball of balls) {
if (ball.isSunk || ball.number === 0) continue;
const ballToCue = ball.pos.subtract(cueBall.pos);
const proj = ballToCue.dot(aimDir);
if (proj <= 0) continue;
const perpDistSq = ballToCue.magnitude() ** 2 - proj ** 2;
const totalRadius = cueBall.radius + ball.radius;
if (perpDistSq < totalRadius ** 2) {
const distToImpact = proj - Math.sqrt(totalRadius ** 2 - perpDistSq);
if (distToImpact >= 0 && distToImpact < closestHit.dist) {
closestHit = {
dist: distToImpact,
ball: ball
};
}
}
}
if (closestHit.ball) {
const targetBall = closestHit.ball;
const cueImpactPos = cueBall.pos.add(aimDir.multiply(closestHit.dist));
const targetDir = targetBall.pos.subtract(cueImpactPos).normalize();
const startPoint = targetBall.pos;
const endPoint = startPoint.add(targetDir.multiply(targetBall.radius * 4));
ctx.save();
ctx.beginPath();
ctx.moveTo(startPoint.x, startPoint.y);
ctx.lineTo(endPoint.x, endPoint.y);
ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
ctx.lineWidth = 2;
ctx.setLineDash([4, 4]);
ctx.stroke();
ctx.restore();
}
}
};
const AI = {
isPathClear(startPos, endPos, ballToIgnore1, ballToIgnore2) {
const lineVec = endPos.subtract(startPos);
const lineMagSq = lineVec.x ** 2 + lineVec.y ** 2;
for (const ball of balls) {
if (ball.isSunk || ball === ballToIgnore1 || ball === ballToIgnore2) continue;
const ballVec = ball.pos.subtract(startPos);
const t = ballVec.dot(lineVec) / lineMagSq;
if (t > 0.01 && t < 0.99) {
const closestPoint = startPos.add(lineVec.multiply(t));
const distSq = (closestPoint.x - ball.pos.x) ** 2 + (closestPoint.y - ball.pos.y) ** 2;
if (distSq < (ball.radius * 2.1) ** 2) return false;
}
}
return true;
},
takeShot() {
if (gameState !== 'AWAITING_INPUT' || Game.currentPlayer !== ai) return;
let bestShot = this.findBestShot();
if (!bestShot || !bestShot.aimPos) {
let targetBalls = [];
if (Game.isTableOpen) {
targetBalls = balls.filter(b => !b.isSunk && b.type !== '8ball' && b.type !== 'cue');
} else {
targetBalls = balls.filter(b => b.type === ai.ballType && !b.isSunk);
if (targetBalls.length === 0) {
targetBalls = balls.filter(b => b.type === '8ball' && !b.isSunk);
}
}
if (targetBalls.length > 0) {
const cueBall = balls[0];
let closestTarget = targetBalls[0];
let minDistance = Infinity;
for (const ball of targetBalls) {
const dist = cueBall.pos.subtract(ball.pos).magnitude();
if (dist < minDistance) {
minDistance = dist;
closestTarget = ball;
}
}
bestShot = {
aimPos: closestTarget.pos,
power: 20
};
} else {
bestShot = {
aimPos: new Vector(balls[0].pos.x + 10, balls[0].pos.y),
power: 15
};
}
}
const finalDir = bestShot.aimPos.subtract(balls[0].pos).normalize();
balls[0].vel = finalDir.multiply(bestShot.power);
Sound.playShot(bestShot.power / 40);
gameState = 'SHOT_IN_PROGRESS';
Physics.shotData = {
sunkBalls: [],
firstHit: null,
hitRailAfterContact: false
};
balls.forEach(b => (b.hitRail = false));
},
findBestShot() {
let bestShot = {
score: -Infinity,
target: null,
pocket: null,
aimPos: null,
power: 0
};
const cueBall = balls[0];
let targetBalls = [];
if (Game.isTableOpen) {
targetBalls = balls.filter(b => !b.isSunk && b.type !== '8ball' && b.type !== 'cue');
} else {
targetBalls = balls.filter(b => b.type === ai.ballType && !b.isSunk);
if (targetBalls.length === 0) {
targetBalls = balls.filter(b => b.type === '8ball' && !b.isSunk);
}
}
if (targetBalls.length === 0) return null;
for (const target of targetBalls) {
for (const pocket of pockets) {
let effectivePocketPos = pocket.pos;
const centerPocketVerticalOffset = cueBall.radius * 0.75;
if (!pocket.isCorner) {
if (pocket.pos.y < canvas.height / 2) {
effectivePocketPos = pocket.pos.add(new Vector(0, centerPocketVerticalOffset));
} else {
effectivePocketPos = pocket.pos.subtract(new Vector(0, centerPocketVerticalOffset));
}
}
const targetToPocketDir = effectivePocketPos.subtract(target.pos).normalize();
let aimPos = target.pos.subtract(targetToPocketDir.multiply(cueBall.radius + target.radius));
if (!pocket.isCorner) {
const perpDir = new Vector(-targetToPocketDir.y, targetToPocketDir.x);
const centerPocketLateralOffset = cueBall.radius * 0.05;
if (target.pos.x < canvas.width / 2) {
aimPos = aimPos.add(perpDir.multiply(centerPocketLateralOffset));
} else {
aimPos = aimPos.subtract(perpDir.multiply(centerPocketLateralOffset));
}
}
if (!this.isPathClear(cueBall.pos, aimPos, cueBall, target)) continue;
if (!this.isPathClear(target.pos, effectivePocketPos, target, cueBall)) continue;
const cueToAimDir = aimPos.subtract(cueBall.pos).normalize();
const angleBonus = cueToAimDir.dot(targetToPocketDir);
if (angleBonus < 0.05) continue;
let score = 1000;
score += (1 / (cueBall.pos.subtract(aimPos).magnitude() + target.pos.subtract(effectivePocketPos).magnitude())) * 200;
score += angleBonus * 100;
if (target.type === '8ball') score *= 2;
if (score > bestShot.score) {
const power = Math.min(10 + (cueBall.pos.subtract(aimPos).magnitude() + target.pos.subtract(effectivePocketPos).magnitude()) / 30, 35);
bestShot = {
score,
target,
pocket,
aimPos,
power
};
}
}
}
if (bestShot.score === -Infinity) {
const rails = [{
y: 0
}, {
y: canvas.height
}, {
x: 0
}, {
x: canvas.width
}];
for (const target of targetBalls) {
for (const pocket of pockets) {
for (const rail of rails) {
let virtualPocketPos = (rail.y !== undefined) ?
new Vector(pocket.pos.x, 2 * rail.y - pocket.pos.y) :
new Vector(2 * rail.x - pocket.pos.x, pocket.pos.y);
const targetToVirtualPocket = virtualPocketPos.subtract(target.pos);
const bankPointDir = targetToVirtualPocket.normalize();
const aimPos = target.pos.subtract(bankPointDir.multiply(cueBall.radius + target.radius));
if (!this.isPathClear(cueBall.pos, aimPos, cueBall, target)) continue;
const cueToAimDir = aimPos.subtract(cueBall.pos).normalize();
const angleBonus = cueToAimDir.dot(bankPointDir);
if (angleBonus < 0.1) continue;
let score = 500;
score += (1 / targetToVirtualPocket.magnitude()) * 100 + angleBonus * 50;
if (target.type === '8ball') score *= 2;
if (score > bestShot.score) {
const power = Math.min(15 + targetToVirtualPocket.magnitude() / 25, 40);
bestShot = {
score,
target,
pocket,
aimPos,
power
};
}
}
}
}
}
if (bestShot.score === -Infinity) {
for (const target of targetBalls) {
const tableCenter = new Vector(canvas.width / 2, canvas.height / 2);
const targetToCenterDir = tableCenter.subtract(target.pos).normalize();
const aimPos = target.pos.add(targetToCenterDir.multiply(cueBall.radius + target.radius));
if (!this.isPathClear(cueBall.pos, aimPos, cueBall, target)) continue;
const cueToTargetDist = cueBall.pos.subtract(target.pos).magnitude();
const score = 200 - cueToTargetDist;
if (score > bestShot.score) {
bestShot = {
score,
target,
pocket: null,
aimPos,
power: 15
};
}
}
}
return bestShot.score > -Infinity ? bestShot : null;
},
placeBall(isBreakFoul) {
let bestPlacement = {
score: -Infinity,
position: null
};
const cueBall = balls[0];
const step = cueBall.radius * 3;
const startX = cueBall.radius;
const endX = isBreakFoul ? canvas.width / 4 - cueBall.radius : canvas.width - cueBall.radius;
for (let x = startX; x < endX; x += step) {
for (let y = cueBall.radius; y < canvas.height; y += step) {
const testPos = new Vector(x, y);
if (balls.slice(1).some(b => !b.isSunk && testPos.subtract(b.pos).magnitude() < cueBall.radius * 2.1)) continue;
cueBall.pos = testPos;
const shot = this.findBestShot();
if (shot && shot.score > bestPlacement.score) {
bestPlacement = {
score: shot.score,
position: testPos
};
}
}
}
cueBall.pos = bestPlacement.position || new Vector(isBreakFoul ? canvas.width / 8 : canvas.width * 0.75, canvas.height / 2);
gameState = 'AWAITING_INPUT';
setTimeout(() => this.takeShot(), 1000);
},
};
playAgainBtn.addEventListener('click', () => {
Sound.playClick();
Game.startNewGame();
});
howToPlayBtn.addEventListener('click', () => {
Sound.playClick();
rulesModal.style.display = 'flex';
});
closeModalBtn.addEventListener('click', () => {
Sound.playClick();
rulesModal.style.display = 'none';
});
window.addEventListener('click', e => {
if (e.target == rulesModal) rulesModal.style.display = 'none';
});
window.addEventListener('resize', () => Game.handleResize());
Sound.init();
Input.init();
Game.handleResize();
Game.startNewGame();
});
</script>
<script>
(function() {
const css = `
#landscape-warning-overlay {
display: none;
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: #000;
color: #0f0;
z-index: 999999;
flex-direction: column;
justify-content: center;
align-items: center;
text-align: center;
font-family: Consolas, 'Courier New', monospace;
padding: 20px;
box-sizing: border-box;
}

/* Vis kun på skjermer som er høyere enn de er brede (Portrett) */
@media screen and (orientation: portrait) {
#landscape-warning-overlay {
display: flex !important;
}
}

#landscape-warning-overlay svg {
width: 80px;
height: 80px;
fill: #0f0;
margin-bottom: 20px;
animation: rotate-phone-anim 2s infinite ease-in-out;
}

#landscape-warning-overlay p {
font-size: 1.2em;
text-transform: uppercase;
letter-spacing: 2px;
margin: 0;
text-shadow: 0 0 5px #0f0;
}

@keyframes rotate-phone-anim {
0%, 10% { transform: rotate(0deg); }
40%, 60% { transform: rotate(-90deg); }
90%, 100% { transform: rotate(-90deg); }
}
`;
const style = document.createElement('style');
style.appendChild(document.createTextNode(css));
document.head.appendChild(style);
const overlay = document.createElement('div');
overlay.id = 'landscape-warning-overlay';
overlay.innerHTML = `
<svg viewBox="0 0 24 24">
<path d="M17,1.01L7,1C5.9,1 5,1.9 5,3v18c0,1.1 0.9,2 2,2h10c1.1,0 2,-0.9 2,-2V3C19,1.9 18.1,1.01 17,1.01z M17,21H7l0,-1h10V21z M17,18H7V6h10V18z M7,4V3h10v1H7z"/>
</svg>
<p>Please Rotate Device</p>
`;
document.body.appendChild(overlay);
})();
</script>
</body>
</html>