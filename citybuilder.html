<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>City Builder</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text x=%2250%22 y=%2275%22 font-size=%2280%22 text-anchor=%22middle%22>%F0%9F%8F%A0</text></svg>">
<style>
  html {
    box-sizing: border-box;
  }

  *,
  *::before,
  *::after {
    box-sizing: inherit;
  }

  html,
  body {
    margin: 0;
    padding: 0;
    height: 100%;
    overflow: hidden;
    font-family: sans-serif;
    background-color: #1a1a1a;
    color: #f0f0f0;
  }

  h1,
  h2,
  h3 {
    text-align: center;
    color: #ffc107;
    margin: 10px 0;
    font-weight: 300;
  }

  hr {
    border: none;
    border-top: 1px solid #444;
    margin: 15px 0;
  }

  #game-container {
    display: flex;
    width: 100vw;
    height: 100vh;
    justify-content: center;
    align-items: center;
    background-color: #000;
  }

  #game-layout {
    display: flex;
    flex-direction: row;
    width: 100%;
    height: 100%;
    border: none;
    background-color: #000;
    box-shadow: none;
    border-radius: 0;
    position: relative;
  }

  #ui-panel {
    width: 280px;
    flex-shrink: 0;
    height: 100%;
    padding: 10px 15px;
    overflow-y: auto;
    border-right: 2px solid #444;
  }

  #stats p {
    margin: 5px 0;
    font-size: 14px;
  }

  #budget-details {
    padding-left: 10px;
    border-left: 2px solid #555;
    margin-top: 5px;
  }

  #tax-rate-controls {
    display: flex;
    justify-content: space-around;
    align-items: center;
    gap: 5px;
    padding: 5px 0;
  }

  #map-container {
    flex-grow: 1;
    height: 100%;
    position: relative;
    overflow: auto;
    cursor: default;
    border: none;
  }

  #grid-container {
    position: relative;
    border: none;
  }

  #game-canvas {
    position: sticky;
    top: 0;
    left: 0;
    z-index: 1;
  }

  .build-cursor {
    cursor: cell;
  }

  .bulldoze-cursor {
    cursor: not-allowed;
  }

  .tool-btn,
  .tax-btn,
  .action-btn,
  .control-btn,
  #new-game-btn {
    display: inline-flex;
    justify-content: center;
    align-items: center;
    padding: 8px 12px;
    margin: 0;
    border-radius: 5px;
    cursor: pointer;
    font-weight: bold;
    font-size: 14px;
    border: 1px solid #777;
    text-decoration: none;
    transition: background-color 0.2s, border-color 0.2s, color 0.2s;
  }

  .tool-btn-grid {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 5px;
  }

  .tool-btn {
    width: 100%;
    background-color: #111;
    color: #fff;
    text-align: left;
    justify-content: flex-start;
    font-size: 14px;
    font-weight: 400;
    padding: 10px 8px;
    white-space: nowrap;
  }

  .tool-btn:hover {
    background-color: #444;
    border-color: #999;
  }

  .tool-btn.active {
    background-color: #ffc107;
    color: #000;
    border-color: #f39c12;
  }

  .tax-btn {
    background-color: #555;
    color: #fff;
    flex-grow: 1;
  }

  .tax-btn.active {
    background-color: #4caf50;
    border-color: #81c784;
  }

  .button-toolbar {
    display: flex;
    flex-wrap: wrap;
    justify-content: flex-start;
    gap: 8px;
  }

  .button-toolbar h3 {
    width: 100%;
    text-align: center;
    margin-bottom: 10px;
  }

  .action-btn,
  .control-btn,
  #new-game-btn {
    flex-grow: 1;
  }

  #save-btn {
    background-color: #4caf50;
    color: white;
    border-color: #388e3c;
  }

  #city-log-btn {
    background-color: #ff9800;
    color: white;
    border-color: #f57c00;
  }

  #how-to-play-btn {
    background-color: #03a9f4;
    color: white;
    border-color: #0288d1;
  }

  #economy-btn {
    background-color: #673ab7;
    color: white;
    border-color: #512da8;
  }

  #new-game-btn {
    background-color: #f44336;
    color: white;
    border-color: #d32f2f;
  }

  .control-btn {
    background-color: #555;
    color: white;
    font-size: 18px;
  }

  #night-overlay {
    display: none;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(25, 25, 50, 0.2);
    z-index: 5;
    pointer-events: none;
  }

  .night-mode #night-mode-btn {
    background-color: #ffc107;
    color: #000;
  }

  .night-mode #night-overlay {
    display: block;
  }

  .night-mode .action-btn {
    background-color: #bdc3c7;
    color: #2c3e50;
    border-color: #95a5a6;
  }

  .night-mode .action-btn:hover {
    background-color: #ecf0f1;
  }

  .visual-effect-layer {
    position: absolute;
    top: 0;
    left: 0;
    pointer-events: none;
    z-index: 10;
    overflow: hidden;
  }

  .cloud,
  .cloud-shadow {
    position: absolute;
    border-radius: 50%;
    animation: drift 120s linear infinite;
  }

  .cloud {
    background-color: rgba(255, 255, 255, 0.4);
  }

  .cloud-shadow {
    background-color: rgba(0, 0, 0, 0.2);
  }

  @keyframes drift {
    from {
      transform: translateX(-200px);
    }
    to {
      transform: translateX(3400px);
    }
  }

  #minimap-wrapper {
    position: relative;
    width: 100%;
    aspect-ratio: 1/1;
    height: auto;
    margin: 15px 0;
    border: 2px solid #555;
    background-color: #000;
    cursor: crosshair;
    transform: translateZ(0);
    will-change: transform;
    overflow: hidden;
    contain: paint layout;
  }

  #minimap-canvas {
    width: 100%;
    height: 100%;
    background-color: #000;
    border: 1px solid #ffc107;
    image-rendering: pixelated;
  }

  #minimap-viewport {
    position: absolute;
    border: 1px solid #fff;
    box-shadow: 0 0 4px rgba(0, 0, 0, 0.5);
    pointer-events: none;
    transform: translateZ(0);
    will-change: left, top;
  }

  #tooltip {
    position: fixed;
    display: none;
    background-color: rgba(0, 0, 0, 0.8);
    color: #fff;
    padding: 5px 10px;
    border-radius: 4px;
    font-size: 12px;
    pointer-events: none;
    z-index: 1001;
    white-space: pre-wrap;
  }

  #event-ticker,
  .visual-effect-layer,
  .cloud,
  .cloud-shadow,
  #night-overlay,
  .fire-cell {
    pointer-events: none !important;
  }

  #event-ticker {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 11;
    background-color: rgba(0, 0, 0, 0.7);
    color: #ffc107;
    padding: 5px 15px;
    border-radius: 20px;
    font-size: 14px;
    opacity: 0;
    transition: opacity 0.5s;
  }

  .modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.75);
    justify-content: center;
    align-items: center;
  }

  .modal.active {
    display: flex;
  }

  .modal-content {
    background-color: #2c2c2c;
    color: #f0f0f0;
    padding: 20px;
    border: 2px solid #ffc107;
    border-radius: 10px;
    width: 90%;
    max-width: 640px;
    max-height: 85vh;
    overflow-y: auto;
    position: relative;
    box-shadow: 0 0 15px rgba(255, 193, 7, 0.5);
  }

  .modal-content h2 {
    color: #ffc107;
  }

  .modal-content li {
    padding-bottom: 10px;
  }

  .modal-close {
    position: sticky;
    top: 0px;
    left: 0px;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
    color: Orange;
    transition: color 0.2s ease;
    z-index: 1002;
  }

  .modal-close:hover {
    color: #ffc107;
  }

  .text-green {
    color: #81c784;
  }

  .text-red {
    color: #e57373;
  }

  #fireworks-container {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%);
    z-index: 5000;
    cursor: pointer;
    overflow: hidden;
  }

  #fireworks-container.active {
    display: block;
  }

  .congrats-text {
    position: absolute;
    top: 40%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    z-index: 100;
    width: 90%;
  }

  .congrats-text h1 {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    font-size: clamp(2.5rem, 7vw, 7rem);
    font-weight: bold;
    color: #ffc107;
    margin-bottom: 20px;
    animation: text-glow 1.5s ease-in-out infinite alternate;
  }

  .congrats-text p {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    font-size: clamp(1rem, 2.5vw, 2.2rem);
    color: #f0f0f0;
    text-shadow: 0 0 5px rgba(0, 0, 0, 0.7);
  }

  @keyframes text-glow {
    from {
      text-shadow: 0 0 10px #ffc107, 0 0 20px #ffc107, 0 0 30px #f39c12;
    }
    to {
      text-shadow: 0 0 20px #f39c12, 0 0 35px #f39c12, 0 0 50px #f1c40f;
    }
  }

  .explosion {
    position: absolute;
    width: 4px;
    height: 4px;
    border-radius: 50%;
    transform-origin: 50% 50%;
    animation: explosion-anim 1.2s ease-in-out infinite;
  }

  .explosion::before {
    content: '';
    position: absolute;
    left: -2px;
    top: -2px;
    width: inherit;
    height: inherit;
    border-radius: 50%;
    box-shadow: 15px 23px 5px #ff0040, -11px -20px 6px #00ffb8, 23px -1px 3px #9d00ff, -1px -25px 5px #ffc107, 24px 21px 4px #00aeff, 11px -14px 6px #ff4d00, -12px -24px 3px #00ff73, 21px 11px 5px #ff00d9, -25px 14px 4px #a6ff00, -25px -10px 6px #ff0062, 11px 29px 3px #00ffea, -11px -7px 5px #ffc107, 18px -10px 4px #0066ff, -23px -9px 6px #ff002f, 1px 22px 3px #a6ff00, -2px -23px 5px #00ffd0, 15px -25px 4px #ff00a2, -13px 25px 6px #b300ff;
  }

  @keyframes explosion-anim {
    0% {
      transform: scale(0.1) rotate(0deg);
      opacity: 1;
    }
    60% {
      opacity: 1;
    }
    100% {
      transform: scale(20) rotate(90deg);
      opacity: 0;
    }
  }

  .explosion:nth-child(1) {
    left: 91%;
    top: 32%;
    animation-delay: 0.8s;
  }

  .explosion:nth-child(2) {
    left: 81%;
    top: 69%;
    animation-delay: 0.2s;
  }

  .explosion:nth-child(3) {
    left: 2%;
    top: 60%;
    animation-delay: 1.1s;
  }

  .explosion:nth-child(4) {
    left: 16%;
    top: 8%;
    animation-delay: 1.5s;
  }

  .explosion:nth-child(5) {
    left: 63%;
    top: 5%;
    animation-delay: 0.1s;
  }

  .explosion:nth-child(6) {
    left: 18%;
    top: 68%;
    animation-delay: 2.3s;
  }

  .explosion:nth-child(7) {
    left: 91%;
    top: 88%;
    animation-delay: 1.7s;
  }

  .explosion:nth-child(8) {
    left: 89%;
    top: 22%;
    animation-delay: 2.1s;
  }

  .explosion:nth-child(9) {
    left: 45%;
    top: 45%;
    animation-delay: 0.5s;
  }

  .explosion:nth-child(10) {
    left: 8%;
    top: 23%;
    animation-delay: 2.8s;
  }

  .explosion:nth-child(11) {
    left: 69%;
    top: 82%;
    animation-delay: 0.9s;
  }

  .explosion:nth-child(12) {
    left: 42%;
    top: 12%;
    animation-delay: 3.1s;
  }

  @keyframes pulse-fire {
    0% {
      transform: scale(1);
      opacity: 0.8;
    }
    50% {
      transform: scale(1.3);
      opacity: 1;
    }
    100% {
      transform: scale(1);
      opacity: 0.8;
    }
  }

  .fire-cell {
    position: absolute;
    width: 32px;
    height: 32px;
    display: flex;
    justify-content: center;
    align-items: center;
    pointer-events: none;
    z-index: 15;
  }

  .fire-emoji {
    font-size: 28px;
    animation: pulse-fire 1s ease-in-out infinite;
    transform-origin: center;
  }

  ::-webkit-scrollbar {
    width: 6px;
    height: 6px;
  }

  ::-webkit-scrollbar-track {
    background: transparent;
  }

  ::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.2);
    border-radius: 3px;
  }

  ::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 255, 255, 0.5);
  }

  * {
    scrollbar-width: thin;
    scrollbar-color: rgba(255, 255, 255, 0.2) transparent;
  }
</style>
</head>
<body>
<div style="position:fixed;bottom:10px;right:10px;z-index:2147483647;font-family:system-ui,sans-serif">
</div>
<div id="game-container">
  <div id="game-layout">
    <div id="ui-panel">
      <div id="difficulty-control" style="margin-bottom: 15px; border-bottom: 1px solid #444; padding-bottom: 10px;">
        <select id="difficulty-select" style="width:100%; background-color:#333; color:#ffc107; border:1px solid #555; padding:5px; border-radius:4px; font-weight:bold;">
          <option value="easy">Easy Living</option>
          <option value="medium">City Planner</option>
          <option value="hard">Urban Crisis</option>
        </select>
      </div>
      <div id="stats">
        <p>üìÖ Year: <span id="year">2025</span></p>
        <p>üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Population: <span id="population">0</span></p>
        <p>üí∞ Budget: $<span id="budget">100000</span></p>
        <div id="budget-details">
          <p style="color: #4caf50;">Income: $<span id="income">0</span></p>
          <p style="color: #f44336;">Maintenance: $<span id="maintenance">0</span></p>
        </div>
      </div>
      <div id="tax-rate-controls">
        <span>Taxes:</span>
        <button class="tax-btn" data-rate="0.5" title="Set taxes to Low">Low</button>
        <button class="tax-btn active" data-rate="0.7" title="Set taxes to Medium">Medium</button>
        <button class="tax-btn" data-rate="1.0" title="Set taxes to High">High</button>
      </div>
      <div id="minimap-container">
        <div id="minimap-wrapper">
          <canvas id="minimap-canvas"></canvas>
          <div id="minimap-viewport"></div>
        </div>
      </div>
      <div class="tool-btn-grid" style="margin-top: 15px;">
        <button class="tool-btn" data-tool="house" title="House">üè† $700</button>
        <button class="tool-btn" data-tool="store" title="Store">üè™ $900</button>
        <button class="tool-btn" data-tool="industry" title="Industry">üè≠ $12k</button>
        <button class="tool-btn" data-tool="road" title="Road">‚ûñ $25</button>
        <button class="tool-btn" data-tool="train-track" title="Train Track">üöÇ $75</button>
        <button class="tool-btn" data-tool="park" title="Park">üå≥ $450</button>
        <button class="tool-btn" data-tool="power-plant" title="Power Plant">‚ö°Ô∏è $8k</button>
        <button class="tool-btn" data-tool="power-line" title="Power Line">üîå $50</button>
        <button class="tool-btn" data-tool="police-station" title="Police Station">üöì $10k</button>
        <button class="tool-btn" data-tool="fire-station" title="Fire Station">üöí $12k</button>
        <button class="tool-btn" data-tool="school" title="School">üè´ $12k</button>
        <button class="tool-btn" data-tool="stadium" title="Stadium">üèüÔ∏è $65k</button>
        <button class="tool-btn" data-tool="airport" title="Airport">‚úàÔ∏è $80k</button>
        <button class="tool-btn" data-tool="bulldoze" title="Bulldoze">üí£ $50</button>
        <button class="tool-btn" data-tool="decoration1" title="Decoration 1">üå≤ $10</button>
        <button class="tool-btn" data-tool="decoration2" title="Decoration 2">üå¥ $10</button>
      </div>
      <div class="button-toolbar" style="margin-top: 15px;">
        <button id="night-mode-btn" class="control-btn" title="Night Mode">üåô</button>
        <button id="save-btn" class="action-btn" title="Save Game">üíæ Save</button>
        <button id="city-log-btn" class="action-btn" title="City Log">üìñ Log</button>
        <button id="economy-btn" class="action-btn" title="Economy">üìä Economy</button>
        <button id="how-to-play-btn" class="action-btn" title="Help">‚ùì Help</button>
        <button id="export-btn" class="action-btn" style="background-color: #009688; border-color: #00796b;" title="Export Save File">üì§ Export</button>
        <button id="import-btn" class="action-btn" style="background-color: #009688; border-color: #00796b;" title="Import Save File">üì• Import</button>
        <input type="file" id="import-input" accept=".json" style="display: none;">
        <button id="new-game-btn" class="action-btn" title="Start a New City">‚ú® New Game</button>
        <button id="mute-sound-btn" class="control-btn" title="Mute/Unmute Sound">üîä</button>
      </div>
    </div>
    <div id="map-container">
      <div id="grid-container">
        <div id="night-overlay"></div>
        <canvas id="game-canvas"></canvas>
        <div id="fire-layer" class="visual-effect-layer"></div>
        <div id="cloud-shadow-layer" class="visual-effect-layer"></div>
        <div id="cloud-layer" class="visual-effect-layer"></div>
      </div>
    </div>
    <div id="event-ticker"></div>
  </div>
</div>
<div id="tooltip"></div>
<div id="how-to-play-modal" class="modal">
  <div class="modal-content"></div>
</div>
<div id="economy-modal" class="modal">
  <div class="modal-content">
    <span id="economy-modal-close" class="modal-close">&times;</span>
    <h2>üìä Economy</h2>
    <div id="economy-details"></div>
  </div>
</div>
<div id="fireworks-container">
  <div class="congrats-text">
    <h1>üèÜ Congratulations! üèÜ</h1>
    <p>You've built an amazing city!</p>
  </div>
  <div class="explosion"></div>
  <div class="explosion"></div>
  <div class="explosion"></div>
  <div class="explosion"></div>
  <div class="explosion"></div>
  <div class="explosion"></div>
  <div class="explosion"></div>
  <div class="explosion"></div>
  <div class="explosion"></div>
  <div class="explosion"></div>
  <div class="explosion"></div>
  <div class="explosion"></div>
</div>
<script>
class AudioManager {

  constructor() {
    this.audioCtx = null;
    this.mainGain = null;
    this.windAmbienceNodes = null;
    this.fireAmbienceNodes = null;
    this.isMuted = false;
    this.initialGainValue = 1.0;
    this.sharedBuffer = null;
  }

  initAudioContext() {
    if (!this.audioCtx) {
      this.audioCtx = new(window.AudioContext || window.webkitAudioContext)();
      this.mainGain = this.audioCtx.createGain();
      this.mainGain.connect(this.audioCtx.destination);
      this.mainGain.gain.value = this.isMuted ? 0 : this.initialGainValue;
      const bufferSize = 2 * this.audioCtx.sampleRate;
      this.sharedBuffer = this.audioCtx.createBuffer(1, bufferSize, this.audioCtx.sampleRate);
      const output = this.sharedBuffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        output[i] = Math.random() * 2 - 1;
      }
    }
  }

  resume() {
    if (this.audioCtx && this.audioCtx.state === 'suspended') {
      return this.audioCtx.resume();
    }
    return Promise.resolve();
  }

  toggleMute() {
    if (!this.audioCtx || !this.mainGain) return;
    this.isMuted = !this.isMuted;
    if (this.isMuted) {
      this.mainGain.gain.setValueAtTime(0, this.audioCtx.currentTime);
    } else {
      this.mainGain.gain.setValueAtTime(this.initialGainValue, this.audioCtx.currentTime);
      this.resume().catch(e => console.error("Error resuming AudioContext on unmute:", e));
    }
  }

  playTrainHorn() {
    this.initAudioContext();
    this.resume();
    if (!this.audioCtx || !this.mainGain) return;
    const ctx = this.audioCtx;
    const t = ctx.currentTime;
    if (!this.trainReverbBuffer) {
      const duration = 3.0;
      const length = ctx.sampleRate * duration;
      const buffer = ctx.createBuffer(2, length, ctx.sampleRate);
      for (let channel = 0; channel < 2; channel++) {
        const channelData = buffer.getChannelData(channel);
        for (let i = 0; i < length; i++) {
          const decay = Math.pow(1 - i / length, 4);
          channelData[i] = (Math.random() * 2 - 1) * decay;
        }
      }
      this.trainReverbBuffer = buffer;
    }
    const osc1 = ctx.createOscillator();
    const osc2 = ctx.createOscillator();
    const sourceGain = ctx.createGain();
    osc1.type = 'sawtooth';
    osc2.type = 'sawtooth';
    osc1.frequency.setValueAtTime(300, t);
    osc2.frequency.setValueAtTime(370, t);
    osc1.connect(sourceGain);
    osc2.connect(sourceGain);
    const dryGain = ctx.createGain();
    dryGain.gain.value = 0.03;
    sourceGain.connect(dryGain);
    dryGain.connect(this.mainGain);
    const convolver = ctx.createConvolver();
    convolver.buffer = this.trainReverbBuffer;
    const wetGain = ctx.createGain();
    wetGain.gain.value = 0.06;
    sourceGain.connect(convolver);
    convolver.connect(wetGain);
    wetGain.connect(this.mainGain);
    sourceGain.gain.setValueAtTime(0, t);
    sourceGain.gain.linearRampToValueAtTime(0.5, t + 0.1);
    sourceGain.gain.setValueAtTime(0.5, t + 0.3);
    sourceGain.gain.linearRampToValueAtTime(0, t + 0.6);
    osc1.start(t);
    osc2.start(t);
    osc1.stop(t + 4.0);
    osc2.stop(t + 4.0);
  }

  playBuildingSound() {
    this.initAudioContext();
    this.resume();
    if (!this.audioCtx || !this.mainGain) return;
    const ctx = this.audioCtx;
    const dest = this.mainGain;
    const buffer = this.sharedBuffer || ctx.createBuffer(1, ctx.sampleRate * 0.1, ctx.sampleRate);
    const noise = ctx.createBufferSource();
    noise.buffer = buffer;
    const filter = ctx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(1000, ctx.currentTime);
    const gain = ctx.createGain();
    gain.gain.setValueAtTime(0.3, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.1);
    noise.connect(filter).connect(gain).connect(dest);
    noise.start(ctx.currentTime);
    noise.stop(ctx.currentTime + 0.1);
  }

  playSirenEffect() {
    this.initAudioContext();
    this.resume();
    if (!this.audioCtx || !this.mainGain) return;
    const ctx = this.audioCtx;
    const dest = this.mainGain;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    const panner = ctx.createStereoPanner();
    osc.connect(gain);
    gain.connect(panner);
    panner.connect(dest);
    osc.type = 'square';
    gain.gain.setValueAtTime(0.04, ctx.currentTime);
    osc.frequency.value = 1000;
    osc.start();
    let highTone = true;
    let cycles = 0;
    const maxCycles = 4;
    const intervalTime = 350;
    const sirenInterval = setInterval(() => {
      if (cycles >= maxCycles) {
        clearInterval(sirenInterval);
        osc.stop();
        osc.disconnect();
        gain.disconnect();
        panner.disconnect();
        return;
      }
      const freq = highTone ? 700 : 1000;
      osc.frequency.setTargetAtTime(freq, ctx.currentTime, 0.05);
      panner.pan.setTargetAtTime(highTone ? -0.8 : 0.8, ctx.currentTime, 0.1);
      highTone = !highTone;
      cycles++;
    }, intervalTime);
  }

  playWindAmbiance() {
    this.initAudioContext();
    this.resume();
    if (!this.audioCtx || !this.mainGain) return;
    const ctx = this.audioCtx;
    const dest = this.mainGain;
    if (this.windAmbienceNodes) {
      this.stopWindAmbiance();
    }
    const t = ctx.currentTime;
    const targetVolume = 0.04;
    const noiseNode = ctx.createBufferSource();
    noiseNode.buffer = this.sharedBuffer;
    noiseNode.loop = true;
    const filter = ctx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(300, t);
    filter.Q.setValueAtTime(1, t);
    const lfoFilterSlow = ctx.createOscillator();
    lfoFilterSlow.type = 'sine';
    lfoFilterSlow.frequency.setValueAtTime(0.08, t);
    const lfoFilterSlowGain = ctx.createGain();
    lfoFilterSlowGain.gain.setValueAtTime(100, t);
    lfoFilterSlow.connect(lfoFilterSlowGain).connect(filter.frequency);
    const lfoFilterFast = ctx.createOscillator();
    lfoFilterFast.type = 'sine';
    lfoFilterFast.frequency.setValueAtTime(0.3, t);
    const lfoFilterFastGain = ctx.createGain();
    lfoFilterFastGain.gain.setValueAtTime(50, t);
    lfoFilterFast.connect(lfoFilterFastGain).connect(filter.frequency);
    const masterGain = ctx.createGain();
    masterGain.gain.setValueAtTime(targetVolume, t);
    const lfoVolume = ctx.createOscillator();
    lfoVolume.type = 'sine';
    lfoVolume.frequency.setValueAtTime(0.11, t);
    const lfoVolumeGain = ctx.createGain();
    lfoVolumeGain.gain.setValueAtTime(targetVolume * 0.25, t);
    lfoVolume.connect(lfoVolumeGain).connect(masterGain.gain);
    noiseNode.connect(filter).connect(masterGain).connect(dest);
    lfoFilterSlow.start(t);
    lfoFilterFast.start(t);
    lfoVolume.start(t);
    noiseNode.start(t);
    this.windAmbienceNodes = {
      noiseNode,
      filter,
      lfoFilterSlow,
      lfoFilterSlowGain,
      lfoFilterFast,
      lfoFilterFastGain,
      masterGain,
      lfoVolume,
      lfoVolumeGain
    };
  }

  stopWindAmbiance() {
    if (this.windAmbienceNodes) {
      const {
        noiseNode,
        lfoFilterSlow,
        lfoFilterFast,
        lfoVolume
      } = this.windAmbienceNodes;
      try {
        noiseNode.stop();
        lfoFilterSlow.stop();
        lfoFilterFast.stop();
        lfoVolume.stop();
        noiseNode.disconnect();
        lfoFilterSlow.disconnect();
        lfoFilterFast.disconnect();
        lfoVolume.disconnect();
        this.windAmbienceNodes = null;
      } catch (e) {}
    }
  }

  startFireAmbience() {
    this.initAudioContext();
    this.resume();
    if (this.fireAmbienceNodes) return;
    const ctx = this.audioCtx;
    const dest = this.mainGain;
    const rumbleSrc = ctx.createBufferSource();
    rumbleSrc.buffer = this.sharedBuffer;
    rumbleSrc.loop = true;
    const rumbleFilter = ctx.createBiquadFilter();
    rumbleFilter.type = 'lowpass';
    rumbleFilter.frequency.value = 120;
    const rumbleGain = ctx.createGain();
    rumbleGain.gain.value = 0.5;
    const rumbleLfo = ctx.createOscillator();
    rumbleLfo.type = 'sine';
    rumbleLfo.frequency.value = 0.5;
    const rumbleLfoGain = ctx.createGain();
    rumbleLfoGain.gain.value = 0.2;
    rumbleLfo.connect(rumbleLfoGain).connect(rumbleGain.gain);
    rumbleSrc.connect(rumbleFilter).connect(rumbleGain).connect(dest);
    rumbleSrc.start();
    rumbleLfo.start();
    let isCrackleActive = true;
    const triggerCrackle = () => {
      if (!isCrackleActive) return;
      const t = ctx.currentTime;
      const crackleSrc = ctx.createBufferSource();
      crackleSrc.buffer = this.sharedBuffer;
      crackleSrc.loopStart = Math.random() * 1.0;
      crackleSrc.loopEnd = crackleSrc.loopStart + 0.1;
      const crackleFilter = ctx.createBiquadFilter();
      crackleFilter.type = 'bandpass';
      crackleFilter.frequency.value = 500 + Math.random() * 1000;
      crackleFilter.Q.value = 1.0;
      const crackleGain = ctx.createGain();
      const vol = 0.05 + Math.random() * 0.15;
      crackleGain.gain.setValueAtTime(0, t);
      crackleGain.gain.linearRampToValueAtTime(vol, t + 0.005);
      crackleGain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
      crackleSrc.connect(crackleFilter).connect(crackleGain).connect(dest);
      crackleSrc.start(t);
      crackleSrc.stop(t + 0.15);
      const nextTime = Math.random() * 150 + 50;
      setTimeout(triggerCrackle, nextTime);
    };
    triggerCrackle();
    this.fireAmbienceNodes = {
      rumbleSrc,
      rumbleGain,
      rumbleLfo,
      stopCrackles: () => {
        isCrackleActive = false;
      }
    };
  }

  stopFireAmbience() {
    if (!this.fireAmbienceNodes) return;
    const {
      rumbleSrc,
      rumbleGain,
      rumbleLfo,
      stopCrackles
    } = this.fireAmbienceNodes;
    stopCrackles();
    const t = this.audioCtx.currentTime;
    rumbleGain.gain.cancelScheduledValues(t);
    rumbleGain.gain.setValueAtTime(rumbleGain.gain.value, t);
    rumbleGain.gain.exponentialRampToValueAtTime(0.001, t + 1.0);
    setTimeout(() => {
      try {
        rumbleSrc.stop();
        rumbleLfo.stop();
        rumbleSrc.disconnect();
        rumbleLfo.disconnect();
      } catch (e) {}
    }, 1000);
    this.fireAmbienceNodes = null;
  }

  playThunderEffect() {
    this.initAudioContext();
    this.resume();
    if (!this.audioCtx || !this.mainGain) return;
    const ctx = this.audioCtx;
    const dest = this.mainGain;
    const t = ctx.currentTime;
    const duration = 2.5;
    const bufferSize = ctx.sampleRate * duration;
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const output = buffer.getChannelData(0);
    let lastOut = 0;
    for (let i = 0; i < bufferSize; i++) {
      const white = Math.random() * 2 - 1;
      output[i] = (lastOut + (0.02 * white)) / 1.02;
      lastOut = output[i];
      output[i] *= 3.5;
    }
    const noise = ctx.createBufferSource();
    noise.buffer = buffer;
    const filter = ctx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(800, t);
    filter.frequency.exponentialRampToValueAtTime(50, t + duration);
    const gain = ctx.createGain();
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(1.0, t + 0.05);
    gain.gain.exponentialRampToValueAtTime(0.01, t + duration);
    noise.connect(filter).connect(gain).connect(dest);
    noise.start(t);
    noise.stop(t + duration);
  }

  playMonsterRoar() {
    this.initAudioContext();
    this.resume();
    if (!this.audioCtx || !this.mainGain) return;
    const ctx = this.audioCtx;
    const t = ctx.currentTime;
    const duration = 2.0;
    const osc = ctx.createOscillator();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(70, t);
    osc.frequency.linearRampToValueAtTime(40, t + duration);
    const lfo = ctx.createOscillator();
    lfo.type = 'sine';
    lfo.frequency.value = 25;
    const lfoGain = ctx.createGain();
    lfoGain.gain.value = 600;
    lfo.connect(lfoGain).connect(osc.frequency);
    const oscGain = ctx.createGain();
    oscGain.gain.setValueAtTime(0, t);
    oscGain.gain.linearRampToValueAtTime(0.4, t + 0.2);
    oscGain.gain.exponentialRampToValueAtTime(0.01, t + duration);
    osc.connect(oscGain);
    oscGain.connect(this.mainGain);
    const buffer = this.sharedBuffer;
    const noise = ctx.createBufferSource();
    noise.buffer = buffer;
    const noiseFilter = ctx.createBiquadFilter();
    noiseFilter.type = 'lowpass';
    noiseFilter.frequency.setValueAtTime(600, t);
    noiseFilter.frequency.linearRampToValueAtTime(200, t + duration);
    const noiseGain = ctx.createGain();
    noiseGain.gain.setValueAtTime(0, t);
    noiseGain.gain.linearRampToValueAtTime(0.6, t + 0.1);
    noiseGain.gain.exponentialRampToValueAtTime(0.01, t + duration);
    noise.connect(noiseFilter).connect(noiseGain).connect(this.mainGain);
    osc.start(t);
    lfo.start(t);
    noise.start(t);
    osc.stop(t + duration);
    lfo.stop(t + duration);
    noise.stop(t + duration);
  }
}

let audioManager;
const emojiCache = {};

window.addEventListener('resize', () => {
  for (let key in emojiCache) delete emojiCache[key];
});

function drawCachedEmoji(ctx, emoji, x, y, powered) {
  const key = emoji + (powered ? '_ON' : '_OFF');
  if (!emojiCache[key]) {
    const c = document.createElement('canvas');
    c.width = config.cellSize;
    c.height = config.cellSize;
    const cCtx = c.getContext('2d');
    cCtx.font = emojiFont;
    cCtx.textAlign = 'center';
    cCtx.textBaseline = 'middle';
    if (powered) {
      cCtx.filter = 'brightness(1.2) contrast(1.1)';
    }
    cCtx.fillText(emoji, config.cellSize / 2, config.cellSize / 2 + 2);
    emojiCache[key] = c;
  }
  ctx.drawImage(emojiCache[key], x, y);
}

const config = {
  gridSize: 100,
  cellSize: 32,
  WIN_CONDITION_POPULATION: 400000,
  MAX_LOG_ENTRIES: 100,
  POWER_PLANT_CAPACITY: 800,
  AIRPORT_INCOME_PER_CITIZEN: 0.25,
  CUSTOMER_RADIUS: 6,
  INCOME_PER_PERSON: 1.5,
  ROAD_MAINTENANCE_PER_WEAR: 5,
  INDUSTRY_INCOME: 3500,
  costs: {
    house: 700,
    store: 900,
    industry: 12000,
    park: 450,
    'power-plant': 8000,
    'power-line': 50,
    'police-station': 10000,
    'fire-station': 12000,
    school: 12000,
    stadium: 65000,
    airport: 80000,
    bulldoze: 50,
    road: 25,
    'train-track': 75,
    decoration1: 10,
    decoration2: 10,
  },
  buildingEmojis: {
    house: 'üè†',
    store: 'üè™',
    industry: 'üè≠',
    park: 'üå≥',
    'power-plant': '‚ö°Ô∏è',
    'police-station': 'üöì',
    'fire-station': 'üöí',
    school: 'üè´',
    stadium: 'üèüÔ∏è',
    airport: '‚úàÔ∏è',
    'train-track': 'üöÇ',
    decoration1: 'üå≤',
    decoration2: 'üå¥',
  },
  buildingDisplayNames: {
    house: "House",
    store: "Store",
    industry: "Industrial Zone",
    road: "Road",
    'train-track': "Train Track",
    park: "Park",
    fountainPark: "Fountain Park",
    'power-plant': "Power Plant",
    'power-line': "Power Line",
    'police-station': "Police Station",
    'fire-station': "Fire Station",
    school: "School",
    stadium: "Stadium",
    airport: "Airport",
    bulldoze: "Bulldoze",
    lake: "Lake",
    decoration1: "Decoration 1",
    decoration2: "Decoration 2",
  },
  largeBuildings: ['stadium', 'airport'],
  minimapColors: {
    grass: '#225D25',
    road: '#616161',
    'train-track': '#424242',
    lake: '#0077be',
    building: '#f5deb3',
    industry: '#a52a2a',
    fire: '#ff4500',
  },
  terrainColors: {
    grass: '#225D25',
    road: '#444',
    lake: '#0077be',
  },
  nightTerrainColors: {
    grass: '#134216',
    road: '#212121',
    lake: '#0d47a1',
  },
  jobCapacity: {
    store: 50,
    industry: 300,
    'fire-station': 40,
    'police-station': 40,
    school: 60,
    stadium: 800,
    airport: 1500,
  },
  jobSeekerRatio: 0.2,
  jobDeficitComplaintThreshold: 200,
  difficultySettings: {
    easy: {
      incomeMultiplier: 1.0,
      maintenanceMultiplier: 1.0,
      constructionCostMultiplier: 1.0,
      growthMultiplier: 1.0,
      strictRoads: false,
      strictParks: false
    },
    medium: {
      incomeMultiplier: 0.75,
      maintenanceMultiplier: 1.25,
      constructionCostMultiplier: 1.1,
      growthMultiplier: 0.85,
      strictRoads: true,
      strictParks: false
    },
    hard: {
      incomeMultiplier: 0.45,
      maintenanceMultiplier: 1.6,
      constructionCostMultiplier: 1.25,
      growthMultiplier: 0.6,
      strictRoads: true,
      strictParks: true
    }
  }
};

let gameState = {
  budget: 100000,
  population: 0,
  year: 2025,
  taxRate: 0.7,
  currentTool: '',
  isGameOver: false,
  isDraggingMinimap: false,
  isDisasterAnimating: false,
  gameLog: [],
  gameInterval: null,
};

let world = [];
let pollutionGrid = new Uint8Array(config.gridSize * config.gridSize);
let industrialZones = [];
let trains = [];
let policeCars = [];
let fireTrucks = [];

function findShortestPath(startIdx, endIdx) {
  if (startIdx === endIdx) return [];
  const queue = [startIdx];
  const visited = new Set([startIdx]);
  const parent = {};
  while (queue.length > 0) {
    const current = queue.shift();
    if (current === endIdx) {
      const path = [endIdx];
      let curr = endIdx;
      while (curr !== startIdx) {
        curr = parent[curr];
        path.unshift(curr);
      }
      return path;
    }
    getNeighbors(current, 1).forEach(neighbor => {
      if (!visited.has(neighbor)) {
        const cell = world[neighbor];
        if (cell && (cell.base === 'road' || cell.base === 'rail-crossing' || neighbor === endIdx)) {
          visited.add(neighbor);
          parent[neighbor] = current;
          queue.push(neighbor);
        }
      }
    });
  }
  return null;
}

function updateAndRenderFireTrucks(ctx) {
  if (Date.now() % 2000 < 50) {
    const fires = [];
    world.forEach((cell, idx) => {
      if (cell.onFire) {
        const alreadyTargeted = fireTrucks.some(truck => truck.targetIndex === idx);
        if (!alreadyTargeted) fires.push(idx);
      }
    });
    fires.forEach(fireIdx => {
      let bestStation = -1;
      let shortestDist = Infinity;
      let bestPath = null;
      world.forEach((cell, idx) => {
        if (cell.building?.type === 'fire-station' && cell.building.powered) {
          const dx = (idx % config.gridSize) - (fireIdx % config.gridSize);
          const dy = Math.floor(idx / config.gridSize) - Math.floor(fireIdx / config.gridSize);
          const dist = dx * dx + dy * dy;
          if (dist < 900) {
            const path = findShortestPath(idx, fireIdx);
            if (path && path.length < shortestDist) {
              shortestDist = path.length;
              bestStation = idx;
              bestPath = path;
            }
          }
        }
      });
      if (bestStation !== -1 && bestPath) {
        fireTrucks.push({
          path: bestPath,
          pathIndex: 0,
          progress: 0,
          targetIndex: fireIdx,
          x: 0,
          y: 0,
          state: 'moving'
        });
        if (audioManager) audioManager.playSirenEffect();
      }
    });
  }
  fireTrucks = fireTrucks.filter(truck => truck.state !== 'done');
  fireTrucks.forEach(truck => {
    if (truck.state === 'moving') {
      truck.progress += 0.04;
      if (truck.progress >= 1) {
        truck.progress = 0;
        truck.pathIndex++;
        if (truck.pathIndex >= truck.path.length - 1) {
          truck.state = 'extinguishing';
          if (world[truck.targetIndex]) {
            world[truck.targetIndex].onFire = false;
            showTickerMessage("üöí Fire extinguished by the fire department!");
          }
        }
      }
    } else if (truck.state === 'extinguishing') {
      truck.progress += 0.02;
      if (truck.progress > 5) {
        truck.state = 'done';
      }
      return;
    }
    const currentIdx = truck.path[truck.pathIndex];
    const nextIdx = truck.path[truck.pathIndex + 1] || currentIdx;
    const curX = (currentIdx % config.gridSize) * config.cellSize;
    const curY = Math.floor(currentIdx / config.gridSize) * config.cellSize;
    const nextX = (nextIdx % config.gridSize) * config.cellSize;
    const nextY = Math.floor(nextIdx / config.gridSize) * config.cellSize;
    if (curX + config.cellSize < camera.x || curX > camera.x + viewport.width ||
      curY + config.cellSize < camera.y || curY > camera.y + viewport.height) {
      return;
    }
    let drawX = curX + (nextX - curX) * truck.progress;
    let drawY = curY + (nextY - curY) * truck.progress;
    if (truck.state === 'extinguishing') {
      drawX = (truck.targetIndex % config.gridSize) * config.cellSize;
      drawY = Math.floor(truck.targetIndex / config.gridSize) * config.cellSize;
    }
    const w = 14;
    const h = 8;
    const dx = nextX - curX;
    const dy = nextY - curY;
    let angle = 0;
    if (dx > 0) angle = 0;
    else if (dx < 0) angle = Math.PI;
    else if (dy > 0) angle = Math.PI / 2;
    else if (dy < 0) angle = -Math.PI / 2;
    ctx.save();
    ctx.translate(drawX + config.cellSize / 2, drawY + config.cellSize / 2);
    ctx.rotate(angle);
    ctx.fillStyle = '#d32f2f';
    ctx.fillRect(-w / 2, -h / 2, w, h);
    ctx.fillStyle = '#fff';
    ctx.fillRect(-w / 2 + 2, -1, w - 4, 2);
    ctx.fillStyle = '#81d4fa';
    ctx.fillRect(w / 2 - 4, -h / 2 + 1, 3, h - 2);
    const time = Date.now();
    const blink = Math.floor(time / 100) % 2 === 0;
    ctx.fillStyle = blink ? '#ff0000' : '#0000ff';
    ctx.beginPath();
    ctx.arc(w / 2 - 1, -h / 2, 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = blink ? '#0000ff' : '#ff0000';
    ctx.beginPath();
    ctx.arc(w / 2 - 1, h / 2, 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  });
}

function updateTrainPaths() {
  const oldTrains = [...trains];
  trains = [];
  const globalVisited = new Set();

  function getTrackNeighbors(index) {
    const x = index % config.gridSize;
    const y = Math.floor(index / config.gridSize);
    const potential = [
      y > 0 ? (y - 1) * config.gridSize + x : -1,
      x < config.gridSize - 1 ? y * config.gridSize + x + 1 : -1,
      y < config.gridSize - 1 ? (y + 1) * config.gridSize + x : -1,
      x > 0 ? y * config.gridSize + x - 1 : -1
    ];
    return potential.filter(n => {
      if (n === -1) return false;
      const cell = world[n];
      return cell && (cell.base === 'train-track' || cell.base === 'rail-crossing');
    });
  }

  function traverseNetwork(startIndex) {
    const network = [];
    const queue = [startIndex];
    const visited = new Set([startIndex]);
    while (queue.length > 0) {
      const current = queue.shift();
      network.push(current);
      const neighbors = getTrackNeighbors(current);
      for (const n of neighbors) {
        if (!visited.has(n)) {
          visited.add(n);
          queue.push(n);
        }
      }
    }
    return network;
  }

  function createPathFromNetwork(networkIndices) {
    if (networkIndices.length === 0) return [];
    const endPoints = networkIndices.filter(idx => getTrackNeighbors(idx).length === 1);
    let startNode = endPoints.length > 0 ? endPoints[0] : networkIndices[0];
    const path = [startNode];
    const visited = new Set([startNode]);
    let current = startNode;
    let hasMore = true;
    while (hasMore) {
      hasMore = false;
      const neighbors = getTrackNeighbors(current);
      for (const n of neighbors) {
        if (!visited.has(n)) {
          visited.add(n);
          path.push(n);
          current = n;
          hasMore = true;
          break;
        }
      }
    }
    if (path.length < 2) return networkIndices;
    const returnPath = [...path].reverse().slice(1, -1);
    return path.concat(returnPath);
  }
  for (let i = 0; i < world.length; i++) {
    const cell = world[i];
    if (!cell) continue;
    if ((cell.base === 'train-track' || cell.base === 'rail-crossing') && !globalVisited.has(i)) {
      const networkIndices = traverseNetwork(i);
      networkIndices.forEach(idx => globalVisited.add(idx));
      if (networkIndices.length < 2) continue;
      const newPath = createPathFromNetwork(networkIndices);
      let existingTrain = null;
      let preservedPosition = 0;
      for (const oldTrain of oldTrains) {
        const currentCellIndex = oldTrain.path[Math.floor(oldTrain.position)];
        if (networkIndices.includes(currentCellIndex)) {
          existingTrain = oldTrain;
          const newIndexInPath = newPath.indexOf(currentCellIndex);
          if (newIndexInPath !== -1) {
            preservedPosition = newIndexInPath + (oldTrain.position % 1);
          } else {
            preservedPosition = 0;
          }
          break;
        }
      }
      if (existingTrain) {
        trains.push({
          path: newPath,
          position: preservedPosition,
          speed: 0.005
        });
      } else {
        trains.push({
          path: newPath,
          position: 0,
          speed: 0.005
        });
      }
    }
  }
}

function renderTrains(ctx) {
  ctx.fillStyle = 'black';
  ctx.globalAlpha = 1.0;
  trains.forEach(train => {
    train.position += train.speed;
    if (train.position >= train.path.length) {
      train.position -= train.path.length;
    }
    if (Math.random() < 0.0002) {
      audioManager.playTrainHorn();
    }
    const pathIndex = Math.floor(train.position);
    const progress = train.position - pathIndex;
    const currentIndex = train.path[pathIndex];
    const nextIndex = train.path[(pathIndex + 1) % train.path.length];
    if (typeof currentIndex === 'undefined' || typeof nextIndex === 'undefined') return;
    const currentX = (currentIndex % config.gridSize) * config.cellSize + config.cellSize / 2;
    const currentY = Math.floor(currentIndex / config.gridSize) * config.cellSize + config.cellSize / 2;
    const nextX = (nextIndex % config.gridSize) * config.cellSize + config.cellSize / 2;
    const nextY = Math.floor(nextIndex / config.gridSize) * config.cellSize + config.cellSize / 2;
    const drawX = currentX + (nextX - currentX) * progress;
    const drawY = currentY + (nextY - currentY) * progress;
    ctx.fillText('üöÇ', drawX, drawY);
  });
}

function initEmptyWorld() {
  world = Array(config.gridSize * config.gridSize).fill(null).map(() => ({
    base: 'grass',
    building: null,
    hasPowerLine: false,
    onFire: false,
    roadWear: 0,
    crimeLevel: 0,
    hasTraffic: false,
  }));
  pollutionGrid.fill(0);
  industrialZones = [];
  policeCars = [];
  generateLakes();
}

function generateLakes() {
  const numLakes = Math.floor(Math.random() * 5) + 3;
  for (let i = 0; i < numLakes; i++) {
    const lakeSize = Math.floor(Math.random() * 100) + 50;
    let x = Math.floor(Math.random() * config.gridSize);
    let y = Math.floor(Math.random() * config.gridSize);
    for (let j = 0; j < lakeSize; j++) {
      const index = y * config.gridSize + x;
      if (index >= 0 && index < world.length && world[index]) {
        world[index].base = 'lake';
      }
      x += Math.floor(Math.random() * 3) - 1;
      y += Math.floor(Math.random() * 3) - 1;
      x = Math.max(0, Math.min(x, config.gridSize - 1));
      y = Math.max(0, Math.min(y, config.gridSize - 1));
    }
  }
}

function loadWorld() {
  const worldDataJson = localStorage.getItem('cityBuilderSave');
  if (!worldDataJson) {
    initEmptyWorld();
    return null;
  }
  try {
    const data = JSON.parse(worldDataJson);
    if (data.world && data.world.length === (config.gridSize * config.gridSize)) {
      world = data.world;
      industrialZones = [];
      policeCars = [];
      world.forEach((cell, index) => {
        if (cell.building?.type === 'industry') {
          industrialZones.push(index);
        }
        if (cell.hasTraffic === undefined) {
          cell.hasTraffic = false;
        }
      });
      if (data.pollutionGrid && data.pollutionGrid.length === (config.gridSize * config.gridSize)) {
        pollutionGrid = new Uint8Array(data.pollutionGrid);
      } else {
        console.warn("Pollution data mismatch or missing. Resetting pollution.");
        pollutionGrid = new Uint8Array(config.gridSize * config.gridSize);
        pollutionGrid.fill(0);
      }
      return data;
    } else {
      console.warn("Saved map size mismatch. Starting new game.");
      initEmptyWorld();
      return null;
    }
  } catch (e) {
    console.error("Could not load save data", e);
    initEmptyWorld();
    return null;
  }
}

function getNeighbors(index, range = 1) {
  const neighbors = [];
  const x = index % config.gridSize;
  const y = Math.floor(index / config.gridSize);
  for (let i = -range; i <= range; i++) {
    for (let j = -range; j <= range; j++) {
      if (i === 0 && j === 0) continue;
      const nx = x + j;
      const ny = y + i;
      if (nx >= 0 && nx < config.gridSize && ny >= 0 && ny < config.gridSize) {
        neighbors.push(ny * config.gridSize + nx);
      }
    }
  }
  return neighbors;
}

function check2x2Area(index) {
  const x = index % config.gridSize;
  const y = Math.floor(index / config.gridSize);
  if (x + 1 >= config.gridSize || y + 1 >= config.gridSize) return false;
  const indices = [index, index + 1, index + config.gridSize, index + config.gridSize + 1];
  return indices.every((i) => i >= 0 && i < world.length && world[i] && world[i].base === 'grass' && !world[i].building && !world[i].hasPowerLine);
}

function clear2x2Building(originIndex) {
  const indices = [originIndex, originIndex + 1, originIndex + config.gridSize, originIndex + config.gridSize + 1];
  indices.forEach((i) => {
    if (i >= 0 && i < world.length && world[i]?.building) {
      world[i].building = null;
    }
  });
}

let gameLayout, mapContainer, gridContainer, canvas, ctx, minimapCanvas, minimapCtx, minimapViewport, cloudLayer, cloudShadowLayer, fireLayer;
let camera = {
  x: 0,
  y: 0
};
let viewport = {
  width: 0,
  height: 0
};
let emojiFont = `${Math.floor(config.cellSize * 0.75)}px sans-serif`;
let hasScrolledToCenter = false;

function initCanvas() {
  gameLayout = document.getElementById('game-layout');
  mapContainer = document.getElementById('map-container');
  gridContainer = document.getElementById('grid-container');
  canvas = document.getElementById('game-canvas');
  ctx = canvas.getContext('2d');
  minimapCanvas = document.getElementById('minimap-canvas');
  minimapCtx = minimapCanvas.getContext('2d');
  minimapViewport = document.getElementById('minimap-viewport');
  cloudLayer = document.getElementById('cloud-layer');
  cloudShadowLayer = document.getElementById('cloud-shadow-layer');
  fireLayer = document.getElementById('fire-layer');
  const totalMapWidth = config.gridSize * config.cellSize;
  const totalMapHeight = config.gridSize * config.cellSize;
  gridContainer.style.width = `${totalMapWidth}px`;
  gridContainer.style.height = `${totalMapHeight}px`;
  document.querySelectorAll('.visual-effect-layer').forEach((layer) => {
    layer.style.width = `${totalMapWidth}px`;
    layer.style.height = `${totalMapHeight}px`;
  });
  minimapCanvas.width = config.gridSize;
  minimapCanvas.height = config.gridSize;
  window.addEventListener('resize', checkCanvasSize);
  checkCanvasSize();
}

function checkCanvasSize() {
  const newWidth = mapContainer.clientWidth;
  const newHeight = mapContainer.clientHeight;
  if (newWidth === 0 || newHeight === 0) return false;
  if (viewport.width !== newWidth || viewport.height !== newHeight) {
    viewport.width = newWidth;
    viewport.height = newHeight;
    canvas.width = newWidth;
    canvas.height = newHeight;
    canvas.style.width = `${newWidth}px`;
    canvas.style.height = `${newHeight}px`;
    emojiFont = `${Math.floor(config.cellSize * 0.75)}px sans-serif`;
    updateMinimapViewport();
    return true;
  }
  return false;
}

function render() {
  checkCanvasSize();
  if (!hasScrolledToCenter) {
    if (viewport.width > 0 && viewport.height > 0) {
      const totalMapWidth = config.gridSize * config.cellSize;
      const totalMapHeight = config.gridSize * config.cellSize;
      mapContainer.scrollLeft = (totalMapWidth - viewport.width) / 2;
      mapContainer.scrollTop = (totalMapHeight - viewport.height) / 2;
      hasScrolledToCenter = true;
      updateMinimapViewport();
    }
  }
  camera.x = mapContainer.scrollLeft;
  camera.y = mapContainer.scrollTop;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.save();
  ctx.translate(Math.floor(-camera.x), Math.floor(-camera.y));
  renderGrid();
  updateAndRenderPoliceCars(ctx);
  updateAndRenderFireTrucks(ctx);
  ctx.restore();
  const fireworks = document.getElementById('fireworks-container');
  const isFireworksActive = fireworks && fireworks.classList.contains('active');
  if (world.some(cell => cell && cell.onFire) || isFireworksActive) {
    audioManager.startFireAmbience();
  } else {
    audioManager.stopFireAmbience();
  }
  requestAnimationFrame(render);
}

function updateAndRenderPoliceCars(ctx) {
  if (!gameState.cachedStationIndices) {
    gameState.cachedStationIndices = [];
    gameState.lastStationCheckTime = 0;
  }
  const now = Date.now();
  if (now - gameState.lastStationCheckTime > 2000 || gameState.cachedStationIndices.length === 0) {
    gameState.cachedStationIndices = [];
    world.forEach((cell, index) => {
      if (cell?.building?.type === 'police-station') {
        gameState.cachedStationIndices.push(index);
      }
    });
    gameState.lastStationCheckTime = now;
  }
  const stationIndices = gameState.cachedStationIndices;
  policeCars = policeCars.filter(car => {
    return stationIndices.includes(car.stationIndex);
  });
  stationIndices.forEach(index => {
    if (!policeCars.find(car => car.stationIndex === index)) {
      policeCars.push({
        stationIndex: index,
        currentIndex: index,
        targetIndex: -1,
        progress: 0,
        speed: 0.02,
        stopped: false,
        stopTimer: 0,
        dir: {
          x: 0,
          y: 0
        }
      });
    }
  });
  policeCars.forEach(car => {
    if (car.stopped) {
      car.stopTimer--;
      if (car.stopTimer <= 0) {
        car.stopped = false;
      }
    } else {
      if (car.targetIndex === -1) {
        const x = car.currentIndex % config.gridSize;
        const y = Math.floor(car.currentIndex / config.gridSize);
        const potentialIndices = [];
        const candidates = [{
          idx: (y - 1) * config.gridSize + x,
          valid: y > 0
        }, {
          idx: (y + 1) * config.gridSize + x,
          valid: y < config.gridSize - 1
        }, {
          idx: y * config.gridSize + (x - 1),
          valid: x > 0
        }, {
          idx: y * config.gridSize + (x + 1),
          valid: x < config.gridSize - 1
        }];
        candidates.forEach(c => {
          if (c.valid) {
            const cell = world[c.idx];
            if (cell && (cell.base === 'road' || cell.base === 'rail-crossing')) {
              if (c.idx !== car.lastIndex) {
                potentialIndices.push(c.idx);
              }
            }
          }
        });
        if (potentialIndices.length === 0 && car.lastIndex !== undefined) {
          potentialIndices.push(car.lastIndex);
        }
        if (potentialIndices.length > 0) {
          car.lastIndex = car.currentIndex;
          car.targetIndex = potentialIndices[Math.floor(Math.random() * potentialIndices.length)];
          const curX = x;
          const curY = y;
          const nextX = car.targetIndex % config.gridSize;
          const nextY = Math.floor(car.targetIndex / config.gridSize);
          car.dir = {
            x: nextX - curX,
            y: nextY - curY
          };
          if (Math.random() < 0.05) {
            car.stopped = true;
            car.stopTimer = 60 + Math.random() * 120;
          }
        }
      }
      if (car.targetIndex !== -1) {
        car.progress += car.speed;
        if (car.progress >= 1) {
          car.currentIndex = car.targetIndex;
          car.targetIndex = -1;
          car.progress = 0;
        }
      }
    }
    const curX = (car.currentIndex % config.gridSize) * config.cellSize;
    const curY = Math.floor(car.currentIndex / config.gridSize) * config.cellSize;
    if (curX + config.cellSize < camera.x || curX > camera.x + viewport.width ||
      curY + config.cellSize < camera.y || curY > camera.y + viewport.height) {
      return;
    }
    let drawX = curX;
    let drawY = curY;
    if (car.targetIndex !== -1) {
      const nextX = (car.targetIndex % config.gridSize) * config.cellSize;
      const nextY = Math.floor(car.targetIndex / config.gridSize) * config.cellSize;
      drawX = curX + (nextX - curX) * car.progress;
      drawY = curY + (nextY - curY) * car.progress;
    }
    const laneOffset = 8;
    let offsetX = 0;
    let offsetY = 0;
    let dirX = car.dir.x;
    let dirY = car.dir.y;
    if (dirX === 0 && dirY === 0) dirY = 1;
    if (dirY !== 0) offsetX = -laneOffset;
    else if (dirX !== 0) offsetY = -laneOffset;
    let carW = 12;
    let carH = 7;
    if (dirY !== 0) {
      carW = 7;
      carH = 12;
    }
    const centerX = drawX + config.cellSize / 2;
    const centerY = drawY + config.cellSize / 2;
    const finalX = centerX + offsetX - carW / 2;
    const finalY = centerY + offsetY - carH / 2;
    ctx.fillStyle = '#0044ff';
    ctx.fillRect(finalX, finalY, carW, carH);
    const time = Date.now();
    const blink = Math.floor(time / 150) % 2 === 0;
    if (dirY !== 0) {
      ctx.fillStyle = blink ? '#ff0000' : '#0000ff';
      ctx.fillRect(finalX + 1, finalY + 4, 2, 3);
      ctx.fillStyle = blink ? '#0000ff' : '#ff0000';
      ctx.fillRect(finalX + 4, finalY + 4, 2, 3);
    } else {
      ctx.fillStyle = blink ? '#ff0000' : '#0000ff';
      ctx.fillRect(finalX + 4, finalY + 1, 3, 2);
      ctx.fillStyle = blink ? '#0000ff' : '#ff0000';
      ctx.fillRect(finalX + 4, finalY + 4, 3, 2);
    }
  });
}

function getCellRandomValue(x, y) {
  const prime1 = 73856093;
  const prime2 = 19349669;
  const seed = (x * prime1) ^ (y * prime2);
  let val = seed;
  val = ((val >> 13) ^ val);
  val = ((val * 123456789) >> 15) ^ val;
  val = (val >> 17) ^ val;
  return Math.abs(val % 100);
}

function renderGrid() {
  if (viewport.width === 0 || viewport.height === 0) return;
  const startCol = Math.floor(camera.x / config.cellSize);
  const endCol = Math.min(config.gridSize - 1, Math.ceil((camera.x + viewport.width) / config.cellSize));
  const startRow = Math.floor(camera.y / config.cellSize);
  const endRow = Math.min(config.gridSize - 1, Math.ceil((camera.y + viewport.height) / config.cellSize));
  const isNight = gameLayout.classList.contains('night-mode');
  const colors = isNight ? config.nightTerrainColors : config.terrainColors;
  ctx.font = emojiFont;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  const checkRoad = (i) => world[i]?.base === 'road' || world[i]?.base === 'rail-crossing';
  const checkTrack = (i) => world[i]?.base === 'train-track' || world[i]?.base === 'rail-crossing';
  const drawRoadPath = (dx, dy, r, n, s, e, w) => {
    const cx = dx + r;
    const cy = dy + r;
    ctx.beginPath();
    if (n || w) ctx.rect(dx, dy, r, r);
    else {
      ctx.moveTo(cx, cy);
      ctx.arc(cx, cy, r, Math.PI, 1.5 * Math.PI);
    }
    if (n || e) ctx.rect(dx + r, dy, r, r);
    else {
      ctx.moveTo(cx, cy);
      ctx.arc(cx, cy, r, 1.5 * Math.PI, 0);
    }
    if (s || e) ctx.rect(dx + r, dy + r, r, r);
    else {
      ctx.moveTo(cx, cy);
      ctx.arc(cx, cy, r, 0, 0.5 * Math.PI);
    }
    if (s || w) ctx.rect(dx, dy + r, r, r);
    else {
      ctx.moveTo(cx, cy);
      ctx.arc(cx, cy, r, 0.5 * Math.PI, Math.PI);
    }
    ctx.closePath();
  };
  for (let y = startRow; y <= endRow; y++) {
    for (let x = startCol; x <= endCol; x++) {
      const index = y * config.gridSize + x;
      const cell = world[index];
      if (!cell) continue;
      const drawX = x * config.cellSize;
      const drawY = y * config.cellSize;
      const baseType = cell.base;
      const isRoad = baseType === 'road' || baseType === 'rail-crossing';
      const isTrack = baseType === 'train-track' || baseType === 'rail-crossing';
      ctx.fillStyle = (isRoad || isTrack) ? colors.grass : (colors[baseType] || colors.grass);
      ctx.fillRect(drawX, drawY, config.cellSize, config.cellSize);
      if (isRoad) {
        const north = y > 0 && checkRoad(index - config.gridSize);
        const south = y < config.gridSize - 1 && checkRoad(index + config.gridSize);
        const east = x < config.gridSize - 1 && checkRoad(index + 1);
        const west = x > 0 && checkRoad(index - 1);
        const roadColor = isNight ? config.nightTerrainColors.road : config.terrainColors.road;
        ctx.fillStyle = roadColor;
        drawRoadPath(drawX, drawY, config.cellSize / 2, north, south, east, west);
        ctx.fill();
        if (baseType === 'rail-crossing') {
          ctx.fillStyle = '#b7950b';
          ctx.fillRect(drawX + 4, drawY + 4, config.cellSize - 8, config.cellSize - 8);
          ctx.fillStyle = roadColor;
          ctx.fillRect(drawX + 8, drawY + 8, config.cellSize - 16, config.cellSize - 16);
        }
      }
      if (isTrack) {
        const north = y > 0 && checkTrack(index - config.gridSize);
        const south = y < config.gridSize - 1 && checkTrack(index + config.gridSize);
        const east = x < config.gridSize - 1 && checkTrack(index + 1);
        const west = x > 0 && checkTrack(index - 1);
        const railColor = isNight ? '#212121' : '#000000';
        const tieColor = isNight ? '#424242' : '#333333';
        const cs = config.cellSize;
        const midX = drawX + cs / 2;
        const midY = drawY + cs / 2;
        ctx.fillStyle = tieColor;
        const tieW = 2;
        const tieL = cs * 0.4;
        const tieOffset = (cs - tieL) / 2;
        const isSimpleCorner = (north && east && !south && !west) ||
          (north && west && !south && !east) ||
          (south && east && !north && !west) ||
          (south && west && !north && !east);
        if (isSimpleCorner) {
          const numTies = 4;
          let cx, cy, startAngle, endAngle;
          if (north && east) {
            cx = drawX + cs;
            cy = drawY;
            startAngle = Math.PI;
            endAngle = 0.5 * Math.PI;
          } else if (north && west) {
            cx = drawX;
            cy = drawY;
            startAngle = 0;
            endAngle = 0.5 * Math.PI;
          } else if (south && east) {
            cx = drawX + cs;
            cy = drawY + cs;
            startAngle = Math.PI;
            endAngle = 1.5 * Math.PI;
          } else if (south && west) {
            cx = drawX;
            cy = drawY + cs;
            startAngle = 0;
            endAngle = 1.5 * Math.PI;
          }
          for (let i = 0; i < numTies; i++) {
            const t = (i + 0.5) / numTies;
            let angle;
            if (north && east) angle = Math.PI - t * (Math.PI * 0.5);
            else if (north && west) angle = t * (Math.PI * 0.5);
            else if (south && east) angle = Math.PI + t * (Math.PI * 0.5);
            else if (south && west) angle = 2 * Math.PI - t * (Math.PI * 0.5);
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(angle);
            ctx.fillRect(cs / 2 - tieL / 2, -tieW / 2, tieL, tieW);
            ctx.restore();
          }
        } else {
          if (north)
            for (let i = 2; i < cs / 2; i += 6) ctx.fillRect(drawX + tieOffset, drawY + i, tieL, tieW);
          if (south)
            for (let i = cs / 2 + 2; i < cs; i += 6) ctx.fillRect(drawX + tieOffset, drawY + i, tieL, tieW);
          if (east)
            for (let i = cs / 2 + 2; i < cs; i += 6) ctx.fillRect(drawX + i, drawY + tieOffset, tieW, tieL);
          if (west)
            for (let i = 2; i < cs / 2; i += 6) ctx.fillRect(drawX + i, drawY + tieOffset, tieW, tieL);
          if (!north && !south && !east && !west) {
            for (let i = 4; i < cs; i += 6) ctx.fillRect(drawX + tieOffset, drawY + i, tieL, tieW);
          }
        }
        ctx.strokeStyle = railColor;
        ctx.lineWidth = 2;
        ctx.beginPath();
        const rOff = 6;
        const neighbors = (north ? 1 : 0) + (south ? 1 : 0) + (east ? 1 : 0) + (west ? 1 : 0);
        if (neighbors === 4 || neighbors === 3 || (neighbors === 2 && ((north && south) || (east && west)))) {
          if (north) {
            ctx.moveTo(midX - rOff, midY);
            ctx.lineTo(midX - rOff, drawY);
            ctx.moveTo(midX + rOff, midY);
            ctx.lineTo(midX + rOff, drawY);
          }
          if (south) {
            ctx.moveTo(midX - rOff, midY);
            ctx.lineTo(midX - rOff, drawY + cs);
            ctx.moveTo(midX + rOff, midY);
            ctx.lineTo(midX + rOff, drawY + cs);
          }
          if (east) {
            ctx.moveTo(midX, midY - rOff);
            ctx.lineTo(drawX + cs, midY - rOff);
            ctx.moveTo(midX, midY + rOff);
            ctx.lineTo(drawX + cs, midY + rOff);
          }
          if (west) {
            ctx.moveTo(midX, midY - rOff);
            ctx.lineTo(drawX, midY - rOff);
            ctx.moveTo(midX, midY + rOff);
            ctx.lineTo(drawX, midY + rOff);
          }
          if (neighbors === 3 || neighbors === 4) {
            ctx.rect(midX - rOff, midY - rOff, rOff * 2, rOff * 2);
          }
        } else if (isSimpleCorner) {
          const r = cs / 2;
          if (north && east) {
            ctx.arc(drawX + cs, drawY, r - rOff, Math.PI, 0.5 * Math.PI, true);
            ctx.moveTo(drawX + cs + (r + rOff) * Math.cos(Math.PI), drawY + (r + rOff) * Math.sin(Math.PI));
            ctx.arc(drawX + cs, drawY, r + rOff, Math.PI, 0.5 * Math.PI, true);
          } else if (north && west) {
            ctx.arc(drawX, drawY, r - rOff, 0, 0.5 * Math.PI);
            ctx.moveTo(drawX + (r + rOff) * Math.cos(0), drawY + (r + rOff) * Math.sin(0));
            ctx.arc(drawX, drawY, r + rOff, 0, 0.5 * Math.PI);
          } else if (south && east) {
            ctx.arc(drawX + cs, drawY + cs, r - rOff, 1.5 * Math.PI, Math.PI, true);
            ctx.moveTo(drawX + cs + (r + rOff) * Math.cos(1.5 * Math.PI), drawY + cs + (r + rOff) * Math.sin(1.5 * Math.PI));
            ctx.arc(drawX + cs, drawY + cs, r + rOff, 1.5 * Math.PI, Math.PI, true);
          } else if (south && west) {
            ctx.arc(drawX, drawY + cs, r - rOff, 1.5 * Math.PI, 0);
            ctx.moveTo(drawX + (r + rOff) * Math.cos(1.5 * Math.PI), drawY + cs + (r + rOff) * Math.sin(1.5 * Math.PI));
            ctx.arc(drawX, drawY + cs, r + rOff, 1.5 * Math.PI, 0);
          }
        } else {
          if (north || south) {
            ctx.moveTo(midX - rOff, drawY);
            ctx.lineTo(midX - rOff, drawY + cs);
            ctx.moveTo(midX + rOff, drawY);
            ctx.lineTo(midX + rOff, drawY + cs);
          } else {
            ctx.moveTo(drawX, midY - rOff);
            ctx.lineTo(drawX + cs, midY - rOff);
            ctx.moveTo(drawX, midY + rOff);
            ctx.lineTo(drawX + cs, midY + rOff);
          }
        }
        ctx.stroke();
      }
      if (pollutionGrid[index] > 20) {
        ctx.fillStyle = `rgba(139, 69, 19, ${pollutionGrid[index] / 600})`;
        if (isRoad) {
          const north = y > 0 && checkRoad(index - config.gridSize);
          const south = y < config.gridSize - 1 && checkRoad(index + config.gridSize);
          const east = x < config.gridSize - 1 && checkRoad(index + 1);
          const west = x > 0 && checkRoad(index - 1);
          drawRoadPath(drawX, drawY, config.cellSize / 2, north, south, east, west);
          ctx.fill();
        } else {
          ctx.fillRect(drawX, drawY, config.cellSize, config.cellSize);
        }
      }
      if (isRoad && cell.roadWear > 0) {
        ctx.fillStyle = `rgba(0, 0, 0, ${cell.roadWear * 0.2})`;
        const north = y > 0 && checkRoad(index - config.gridSize);
        const south = y < config.gridSize - 1 && checkRoad(index + config.gridSize);
        const east = x < config.gridSize - 1 && checkRoad(index + 1);
        const west = x > 0 && checkRoad(index - 1);
        drawRoadPath(drawX, drawY, config.cellSize / 2, north, south, east, west);
        ctx.fill();
      }
      if (cell.hasTraffic) {
        drawTrafficVariableSpeed(x, y, index, drawX, drawY, cell.roadWear);
      }
      if (cell.building) {
        let emoji = config.buildingEmojis[cell.building.type] || '';
        if (cell.building.type === 'house') {
          const pop = cell.building.population;
          if (pop >= 150) {
            const randVal = getCellRandomValue(x, y);
            const specialMaxCapEmojis = ['üè®', 'üè©', 'üèØ', 'üè∞', 'üíí'];
            const standardMaxCapEmojis = ['üè¢', 'üèõÔ∏è', 'üè§', 'üïã', 'üè¨'];
            if (randVal < 20) {
              emoji = specialMaxCapEmojis[randVal % specialMaxCapEmojis.length];
            } else {
              emoji = standardMaxCapEmojis[randVal % standardMaxCapEmojis.length];
            }
          } else if (pop > 100) {
            emoji = 'üèòÔ∏è';
          } else if (pop > 30) {
            emoji = 'üè°';
          } else {
            emoji = 'üè†';
          }
        } else if (cell.building.type === 'store') {
          emoji = 'üè™';
        } else if (cell.building.type === 'industry') {
          const randVal = getCellRandomValue(x, y);
          const industryEmojis = ['üèóÔ∏è', 'üè≠', 'üöõ'];
          emoji = industryEmojis[randVal % industryEmojis.length];
        }
        if (cell.building.type === 'park' && cell.building.hasFountain) emoji = '‚õ≤Ô∏è';
        drawCachedEmoji(ctx, emoji, drawX, drawY, cell.building.powered);
      }
      if (cell.hasPowerLine) {
        drawPowerLine(x, y, index, drawX, drawY);
      }
      if (cell.onFire) {
        ctx.fillStyle = 'rgba(255, 69, 0, 0.6)';
        ctx.fillRect(drawX, drawY, config.cellSize, config.cellSize);
      }
    }
  }
  renderTrains(ctx);
  if (gameState.kingKongLocation !== undefined && gameState.kingKongLocation !== null) {
    const kx = gameState.kingKongLocation % config.gridSize;
    const ky = Math.floor(gameState.kingKongLocation / config.gridSize);
    const drawKX = kx * config.cellSize + config.cellSize / 2;
    const drawKY = ky * config.cellSize + config.cellSize / 2;
    ctx.font = `${Math.floor(config.cellSize * 2)}px sans-serif`;
    ctx.fillText('ü¶ç', drawKX, drawKY);
  }
}

function updateFireLayer() {
  if (!fireLayer) return;
  fireLayer.innerHTML = '';
  world.forEach((cell, index) => {
    if (cell && cell.onFire) {
      const x = index % config.gridSize;
      const y = Math.floor(index / config.gridSize);
      const fireDiv = document.createElement('div');
      fireDiv.className = 'fire-cell';
      fireDiv.style.left = `${x * config.cellSize}px`;
      fireDiv.style.top = `${y * config.cellSize}px`;
      const emojiSpan = document.createElement('span');
      emojiSpan.className = 'fire-emoji';
      emojiSpan.textContent = 'üî•';
      fireDiv.appendChild(emojiSpan);
      fireLayer.appendChild(fireDiv);
    }
  });
}

function drawPowerLine(x, y, index, drawX, drawY) {
  ctx.fillStyle = '#000';
  const midX = drawX + config.cellSize / 2;
  const midY = drawY + config.cellSize / 2;
  const lineW = 1;
  const dotR = 2;
  let hasConnection = false;
  if (y > 0 && isPowerConnection(index - config.gridSize)) {
    ctx.fillRect(midX - lineW / 2, drawY, lineW, config.cellSize / 2);
    hasConnection = true;
  }
  if (y < config.gridSize - 1 && isPowerConnection(index + config.gridSize)) {
    ctx.fillRect(midX - lineW / 2, midY, lineW, config.cellSize / 2);
    hasConnection = true;
  }
  if (x > 0 && isPowerConnection(index - 1)) {
    ctx.fillRect(drawX, midY - lineW / 2, config.cellSize / 2, lineW);
    hasConnection = true;
  }
  if (x < config.gridSize - 1 && isPowerConnection(index + 1)) {
    ctx.fillRect(midX, midY - lineW / 2, config.cellSize / 2, lineW);
    hasConnection = true;
  }
  if (hasConnection) {
    ctx.beginPath();
    ctx.arc(midX, midY, dotR, 0, 2 * Math.PI);
    ctx.fill();
  }
}

function drawTrafficVariableSpeed(x, y, index, drawX, drawY, roadWear) {
  const north = y > 0 && world[index - config.gridSize].base === 'road';
  const south = y < config.gridSize - 1 && world[index + config.gridSize].base === 'road';
  const east = x < config.gridSize - 1 && world[index + 1].base === 'road';
  const west = x > 0 && world[index - 1].base === 'road';
  const carLength = 10;
  const carBreadth = 6;
  let animSpeed = 6000;
  if (roadWear === 2) animSpeed = 4000;
  else if (roadWear === 3) animSpeed = 2500;
  const animProgress1 = (Date.now() % animSpeed) / animSpeed;
  ctx.fillStyle = '#555';
  const pos1 = config.cellSize * animProgress1;
  const centeredPos1Y = pos1 - (carLength / 2);
  const centeredPos1X = pos1 - (carLength / 2);
  if (north || south) {
    const carXRight = Math.floor(drawX + config.cellSize / 2 + 2);
    const carYRight = Math.floor(drawY + centeredPos1Y);
    ctx.fillRect(carXRight, carYRight, carBreadth, carLength);
  }
  if (east || west) {
    const carXBottom = Math.floor(drawX + centeredPos1X);
    const carYBottom = Math.floor(drawY + config.cellSize / 2 + 2);
    ctx.fillRect(carXBottom, carYBottom, carLength, carBreadth);
  }
}

function isPowerConnection(index) {
  if (index < 0 || index >= world.length) return false;
  const neighbor = world[index];
  return neighbor && (neighbor.hasPowerLine || (neighbor.building && neighbor.building.type !== 'park'));
}

const colorCache = {};

function hexToRgb(hex) {
  if (colorCache[hex]) return colorCache[hex];
  let c;
  if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
    c = hex.substring(1).split('');
    if (c.length == 3) c = [c[0], c[0], c[1], c[1], c[2], c[2]];
    c = '0x' + c.join('');
    return colorCache[hex] = [(c >> 16) & 255, (c >> 8) & 255, c & 255];
  }
  return [0, 0, 0];
}

function updateMinimap() {
  if (!minimapCtx) return;
  const imgData = minimapCtx.createImageData(config.gridSize, config.gridSize);
  const data = imgData.data;
  for (let i = 0; i < world.length; i++) {
    const cell = world[i];
    if (!cell) continue;
    let colorHex = config.minimapColors[cell.base] || config.minimapColors.grass;
    if (cell.building) {
      if (cell.building.type === 'industry') colorHex = config.minimapColors.industry;
      else colorHex = cell.building.powered ? config.minimapColors.building : '#8d6e63';
    }
    if (cell.onFire) colorHex = config.minimapColors.fire;
    const [r, g, b] = hexToRgb(colorHex);
    const idx = i * 4;
    data[idx] = r;
    data[idx + 1] = g;
    data[idx + 2] = b;
    data[idx + 3] = 255;
  }
  minimapCtx.putImageData(imgData, 0, 0);
  updateMinimapViewport();
}

function updateMinimapViewport() {
  if (!minimapViewport || !minimapCanvas || !gridContainer || viewport.width === 0) return;
  const mapW = minimapCanvas.offsetWidth;
  const mapH = minimapCanvas.offsetHeight;
  const totalW = gridContainer.scrollWidth;
  const totalH = gridContainer.scrollHeight;
  if (totalW === 0 || totalH === 0) return;
  const xRatio = viewport.width / totalW;
  const yRatio = viewport.height / totalH;
  minimapViewport.style.width = `${Math.max(0, (xRatio * mapW) - 2)}px`;
  minimapViewport.style.height = `${Math.max(0, (yRatio * mapH) - 2)}px`;
  minimapViewport.style.left = `${(mapContainer.scrollLeft / totalW) * mapW}px`;
  minimapViewport.style.top = `${(mapContainer.scrollTop / totalH) * mapH}px`;
}

function scrollToIndex(index) {
  if (!mapContainer || viewport.width === 0 || viewport.height === 0) return;
  const x = index % config.gridSize;
  const y = Math.floor(index / config.gridSize);
  const targetX = x * config.cellSize;
  const targetY = y * config.cellSize;
  const scrollX = targetX - (viewport.width / 2) + (config.cellSize / 2);
  const scrollY = targetY - (viewport.height / 2) + (config.cellSize / 2);
  mapContainer.scrollTo({
    left: scrollX,
    top: scrollY,
    behavior: 'smooth'
  });
}

function createClouds() {
  if (!cloudLayer || !cloudShadowLayer) return;
  cloudLayer.innerHTML = '';
  cloudShadowLayer.innerHTML = '';
  const numClouds = 5 * (config.gridSize / 50);
  const maxTop = config.gridSize * config.cellSize;
  for (let i = 0; i < numClouds; i++) {
    const cloud = document.createElement('div');
    cloud.className = 'cloud';
    const size = 100 + Math.random() * 150;
    cloud.style.width = `${size}px`;
    cloud.style.height = `${size * 0.6}px`;
    cloud.style.top = `${Math.random() * maxTop}px`;
    cloud.style.animationDelay = `${Math.random() * -120}s`;
    cloudLayer.appendChild(cloud);
    const shadow = document.createElement('div');
    shadow.className = 'cloud-shadow';
    shadow.style.width = cloud.style.width;
    shadow.style.height = cloud.style.height;
    shadow.style.top = `${parseFloat(cloud.style.top) + 20}px`;
    shadow.style.left = `-20px`;
    shadow.style.animationDelay = cloud.style.animationDelay;
    cloudShadowLayer.appendChild(shadow);
  }
}

let tooltip, eventTicker, populationEl, budgetEl, yearEl, incomeEl, maintenanceEl;

function initUIElements() {
  tooltip = document.getElementById('tooltip');
  eventTicker = document.getElementById('event-ticker');
  populationEl = document.getElementById('population');
  budgetEl = document.getElementById('budget');
  yearEl = document.getElementById('year');
  incomeEl = document.getElementById('income');
  maintenanceEl = document.getElementById('maintenance');
}

function updateStatsPanel(state) {
  if (!budgetEl || !populationEl || !yearEl) return;
  budgetEl.textContent = Math.floor(state.budget).toLocaleString();
  populationEl.textContent = state.population.toLocaleString();
  yearEl.textContent = state.year;
}

function updateIncomeExpense(income, maintenance) {
  if (!incomeEl || !maintenanceEl) return;
  incomeEl.textContent = Math.floor(income).toLocaleString();
  maintenanceEl.textContent = Math.floor(maintenance).toLocaleString();
}

function showTooltip(index, e) {
  if (isNaN(index) || index < 0 || index >= world.length || !tooltip) return;
  const cellData = world[index];
  if (!cellData) return;
  let text = '';
  if (cellData.building) {
    text = config.buildingDisplayNames[cellData.building.type] || cellData.building.type;
    if (cellData.building.type === 'park' && cellData.building.hasFountain) text = "Fountain Park";
    if (cellData.building.type === 'house') text += `\nPopulation: ${Math.floor(cellData.building.population)}`;
    if (cellData.building.type === 'power-plant') text += `\nLoad: ${cellData.building.powerLoad || 0} / ${cellData.building.isDamaged ? 0 : config.POWER_PLANT_CAPACITY}`;
    const jobCapacity = config.jobCapacity[cellData.building.type];
    if (jobCapacity !== undefined && cellData.building.employees !== undefined && !cellData.building.isPart) {
      text += `\nEmployees: ${Math.floor(cellData.building.employees)} / ${jobCapacity}`;
    }
    text += `\nPowered: ${cellData.building.powered ? "Yes" : "No"}`;
    if (cellData.building.isDamaged) text += `\n(Damaged!)`;
  } else if (cellData.hasPowerLine) {
    text = "Power Line";
  } else if (cellData.base === 'road') {
    text = "Road";
    if (cellData.roadWear > 0) text += `\nWear Level: ${cellData.roadWear}`;
  } else if (cellData.base === 'lake') {
    text = "Lake";
  }
  const pollution = pollutionGrid[index];
  if (pollution > 20) {
    text += `\nPollution: ${Math.round(pollution / 255 * 100)}%`;
  }
  if (cellData.onFire) text = `üî• ${text} üî•`;
  if (text) {
    tooltip.innerText = text;
    tooltip.style.display = 'block';
    let newX = e.clientX + 15;
    let newY = e.clientY + 15;
    const tooltipWidth = tooltip.offsetWidth;
    const tooltipHeight = tooltip.offsetHeight;
    if (newX + tooltipWidth > window.innerWidth) newX = e.clientX - tooltipWidth - 15;
    if (newY + tooltipHeight > window.innerHeight) newY = e.clientY - tooltipHeight - 15;
    newX = Math.max(0, newX);
    newY = Math.max(0, newY);
    tooltip.style.left = `${newX}px`;
    tooltip.style.top = `${newY}px`;
  } else {
    hideTooltip();
  }
}

function hideTooltip() {
  if (tooltip) tooltip.style.display = 'none';
}

let tickerTimeout;

function showTickerMessage(message) {
  if (!eventTicker) return;
  clearTimeout(tickerTimeout);
  eventTicker.textContent = message;
  eventTicker.style.opacity = 1;
  tickerTimeout = setTimeout(() => {
    eventTicker.style.opacity = 0;
  }, 5000);
}

function showLog(log) {
  const modal = document.getElementById('how-to-play-modal');
  if (!modal) return;
  const modalContent = modal.querySelector('.modal-content');
  if (!modalContent) return;
  modalContent.innerHTML = `<span class="modal-close">&times;</span><h2>City Log</h2>`;
  const logList = document.createElement('ul');
  logList.style.cssText = 'list-style-type: none; padding: 0; margin-top: 15px;';
  if (!log || log.length === 0) {
    logList.innerHTML = `<li>No events logged yet.</li>`;
  } else {
    log.forEach((entry) => {
      const li = document.createElement('li');
      li.textContent = entry;
      li.style.cssText = 'border-bottom: 1px solid #444; padding: 8px 0; font-size: 14px;';
      logList.appendChild(li);
    });
  }
  modalContent.appendChild(logList);
  const closeButton = modalContent.querySelector('.modal-close');
  if (closeButton) {
    closeButton.onclick = () => {
      modal.style.display = 'none';
      audioManager.resume().catch(e => console.error("Error resuming AudioContext on log close:", e));
    };
  }
  modal.style.display = 'flex';
}

function showHelp() {
  const modal = document.getElementById('how-to-play-modal');
  if (!modal) return;
  const modalContent = modal.querySelector('.modal-content');
  if (!modalContent) return;
  modalContent.innerHTML = `<span class="modal-close">&times;</span>
<p style="margin: 0 0 0 0; color: CornFlowerBlue; text-align: center;">&copy; Johnny Heggelund</p>
<h2>City Builder Guide</h2>
<p>Welcome, Mayor! Your goal is to grow a metropolis of <strong>${config.WIN_CONDITION_POPULATION.toLocaleString()}</strong> residents. Avoid bankruptcy at all costs!</p>

<h4>üíº Jobs & Economy</h4>
<ul>
<li><strong>Employment:</strong> Citizens need jobs! High unemployment leads to unhappiness and stops new residents from moving in.</li>
<li><strong>Industry (üè≠):</strong> The backbone of employment. Each zone provides <strong>300 jobs</strong> and high taxes, but generates heavy pollution.</li>
<li><strong>Commercial (üè™):</strong> Provides <strong>50 jobs</strong> and clean income. Profit depends on how many customers live nearby.</li>
<li><strong>Special Buildings:</strong> Stadiums and Airports are expensive but provide massive employment opportunities.</li>
</ul>

<h4>üè° Residential Growth</h4>
<ul>
<li><strong>Evolution:</strong> Houses start small (üè†). To evolve into skyscrapers (üè¢), they need <strong>Power</strong>, <strong>Jobs</strong>, and high <strong>Happiness</strong>.</li>
<li><strong>Happiness:</strong> Boosted by Parks (üå≥), Water (üíß), Police (üöì), Fire Safety (üöí), and Schools (üè´).</li>
<li><strong>Pollution:</strong> Smog from industry kills growth. <strong>Strategy:</strong> Build Parks as "buffer zones" between factories and homes - trees actively clean the air!</li>
</ul>

<h4>‚ö°Ô∏è Infrastructure</h4>
<ul>
<li><strong>Power (‚ö°Ô∏è):</strong> Every building needs power. One Power Plant supports ${config.POWER_PLANT_CAPACITY} buildings.</li>
<li><strong>Roads (‚ûñ):</strong> Heavy traffic wears down roads, increasing maintenance costs. Smart layouts with light traffic allow roads to <strong>repair themselves</strong> over time.</li>
<li><strong>Trains (üöÇ):</strong> Trains boost growth and reduce road wear. You can build tracks <strong>directly over roads</strong> to create crossings.</li>
</ul>

<h4>üéÆ Difficulty Levels</h4>
<ul>
<li><strong>Easy Living:</strong> Standard income and growth. Relaxed rules for roads and parks.</li>
<li><strong>City Planner:</strong> Lower income, higher maintenance costs. Traffic impacts roads more significantly.</li>
<li><strong>Urban Crisis:</strong> Low income, very high costs, slow growth. Strict requirements for road access and park coverage. Disasters are more damaging.</li>
</ul>

<h4>üî• Disasters</h4>
<p>Watch the ticker! Fires, Thunder Storms, Economic Recessions, and Monster attacks can strike at any time!</p>
<p style="text-align: center; margin-top: 20px;"><strong>Good luck, Mayor!</strong></p>`;
  const closeButton = modalContent.querySelector('.modal-close');
  if (closeButton) {
    closeButton.onclick = () => {
      modal.style.display = 'none';
      audioManager.resume().catch(e => console.error("Error resuming AudioContext on help close:", e));
    };
  }
  modal.style.display = 'flex';
}

function showEconomyWindow() {
  const modal = document.getElementById('economy-modal');
  if (!modal) return;
  const economyDetails = document.getElementById('economy-details');
  if (!economyDetails) return;
  const {
    incomeSources,
    expenseSources
  } = getEconomyData(false);
  let incomeHtml = `<hr><h4>Income Distribution</h4><ul>`;
  Object.keys(incomeSources).forEach((key) => {
    if (key !== 'total' && incomeSources[key].count > 0) {
      const name = key.charAt(0).toUpperCase() + key.slice(1);
      const translatedName = {
        Houses: "House Taxes",
        Stores: "Store Sales",
        Airport: "Airport Revenue",
        Industry: "Industrial Profit"
      };
      incomeHtml += `<li>${translatedName[name] || name} (${incomeSources[key].count}): <strong>$${Math.floor(incomeSources[key].totalIncome).toLocaleString()}</strong></li>`;
    }
  });
  incomeHtml += `</ul><p class="text-green"><strong>Total Income: $${Math.floor(incomeSources.total).toLocaleString()}</strong></p><hr>`;
  let expenseHtml = `<h4>Expense Distribution</h4><ul>`;
  Object.keys(expenseSources).forEach((key) => {
    if (key !== 'total' && expenseSources[key].count > 0) {
      const name = (key === 'road') ? 'Road Maintenance' : (config.buildingDisplayNames[key] || key);
      expenseHtml += `<li>${name} (${expenseSources[key].count}): <strong>$${Math.floor(expenseSources[key].totalMaintenance).toLocaleString()}</strong></li>`;
    }
  });
  expenseHtml += `</ul><p class="text-red"><strong>Total Expenses: $${Math.floor(expenseSources.total).toLocaleString()}</strong></p><hr>`;
  const netProfit = incomeSources.total - expenseSources.total;
  const netHtml = `<h3>Annual Net Result: <strong class="${netProfit >= 0 ? 'text-green' : 'text-red'}">$${Math.floor(netProfit).toLocaleString()}</strong></h3>`;
  economyDetails.innerHTML = netHtml + incomeHtml + expenseHtml;
  modal.style.display = 'flex';
}

function simulatePollution() {
  for (let i = 0; i < pollutionGrid.length; i++) {
    if (pollutionGrid[i] > 0) {
      pollutionGrid[i] = Math.max(0, pollutionGrid[i] - 1);
    }
  }
  for (const index of industrialZones) {
    const cell = world[index];
    if (cell && cell.building?.powered) {
      pollutionGrid[index] = Math.min(255, pollutionGrid[index] + 40);
      getNeighbors(index, 6).forEach((nIndex) => {
        if (nIndex >= 0 && nIndex < pollutionGrid.length) {
          pollutionGrid[nIndex] = Math.min(255, pollutionGrid[nIndex] + 5);
        }
      });
    }
  }
  world.forEach((cell, index) => {
    if (cell && cell.building?.type === 'park') {
      const cleanRadius = 3;
      const cleanAmount = 3;
      getNeighbors(index, cleanRadius).forEach((nIndex) => {
        if (nIndex >= 0 && nIndex < pollutionGrid.length) {
          pollutionGrid[nIndex] = Math.max(0, pollutionGrid[nIndex] - cleanAmount);
        }
      });
    }
  });
}

function getEconomyData(isRecession = false) {
  const diffSetting = config.difficultySettings[gameState.difficulty || 'easy'];
  const incomeMult = diffSetting.incomeMultiplier;
  const maintMult = diffSetting.maintenanceMultiplier || 1.0;
  const incomeSources = {
    houses: {
      count: 0,
      totalIncome: 0
    },
    stores: {
      count: 0,
      totalIncome: 0
    },
    industry: {
      count: 0,
      totalIncome: 0
    },
    airport: {
      count: 0,
      totalIncome: 0
    },
    total: 0,
  };
  const expenseSources = {
    house: {
      count: 0,
      totalMaintenance: 0
    },
    store: {
      count: 0,
      totalMaintenance: 0
    },
    industry: {
      count: 0,
      totalMaintenance: 0
    },
    park: {
      count: 0,
      totalMaintenance: 0
    },
    'power-plant': {
      count: 0,
      totalMaintenance: 0
    },
    'police-station': {
      count: 0,
      totalMaintenance: 0
    },
    'fire-station': {
      count: 0,
      totalMaintenance: 0
    },
    school: {
      count: 0,
      totalMaintenance: 0
    },
    stadium: {
      count: 0,
      totalMaintenance: 0
    },
    airport: {
      count: 0,
      totalMaintenance: 0
    },
    road: {
      count: 0,
      totalMaintenance: 0
    },
    total: 0,
  };
  const maintenanceRate = 0.035;
  let currentPopulation = 0;
  world.forEach((cell, index) => {
    if (!cell) return;
    if (cell.building) {
      const type = cell.building.type;
      const cost = config.costs[type] || 0;
      const maintenance = cost * maintenanceRate * maintMult;
      if (expenseSources[type] !== undefined && !cell.building.isPart) {
        expenseSources[type].count++;
        expenseSources[type].totalMaintenance += maintenance;
        expenseSources.total += maintenance;
      }
      if (cell.building.powered) {
        if (type === 'house') {
          const pop = Math.floor(cell.building.population);
          currentPopulation += pop;
          let tax = pop * (gameState.taxRate || 0.7);
          if (isRecession) tax /= 2;
          tax *= incomeMult;
          incomeSources.houses.count++;
          incomeSources.houses.totalIncome += Math.floor(tax);
          incomeSources.total += Math.floor(tax);
        } else if (type === 'store') {
          let nearbyPopulation = 0;
          getNeighbors(index, config.CUSTOMER_RADIUS).forEach((nIndex) => {
            const neighborCell = world[nIndex];
            if (neighborCell?.building?.type === 'house' && neighborCell.building.powered) {
              nearbyPopulation += neighborCell.building.population;
            }
          });
          let storeIncome = Math.floor(nearbyPopulation * config.INCOME_PER_PERSON);
          storeIncome *= incomeMult;
          incomeSources.stores.count++;
          incomeSources.stores.totalIncome += storeIncome;
          incomeSources.total += storeIncome;
        } else if (type === 'industry') {
          let indIncome = config.INDUSTRY_INCOME;
          indIncome *= incomeMult;
          incomeSources.industry.count++;
          incomeSources.industry.totalIncome += indIncome;
          incomeSources.total += indIncome;
        } else if (type === 'airport' && !cell.building.isPart) {
          incomeSources.airport.count++;
        }
      }
    }
    if (cell.base === 'road' && cell.roadWear > 0) {
      const roadMaint = cell.roadWear * config.ROAD_MAINTENANCE_PER_WEAR * maintMult;
      if (expenseSources.road !== undefined) {
        expenseSources.road.count++;
        expenseSources.road.totalMaintenance += roadMaint;
        expenseSources.total += roadMaint;
      }
    }
  });
  if (incomeSources.airport.count > 0) {
    let airportRevenue = Math.floor(currentPopulation * config.AIRPORT_INCOME_PER_CITIZEN) * incomeSources.airport.count;
    airportRevenue *= incomeMult;
    incomeSources.airport.totalIncome = airportRevenue;
    incomeSources.total += airportRevenue;
  }
  return {
    incomeSources,
    expenseSources,
    currentPopulation
  };
}

function simulateYear(state, logFn) {
  let {
    budget,
    population,
    year,
    taxRate,
    difficulty
  } = state;
  const currentDifficulty = difficulty || 'easy';
  const diffSettings = config.difficultySettings[currentDifficulty];
  let isRecessionYear = false;
  let totalPopulationSeekingJobs = 0;
  let totalJobsAvailable = 0;
  const jobProvidingBuildings = [];
  world.forEach((cell, index) => {
    if (!cell) return;
    if (cell.building && config.jobCapacity[cell.building.type] && !cell.building.isPart) {
      cell.building.employees = 0;
      totalJobsAvailable += config.jobCapacity[cell.building.type];
      jobProvidingBuildings.push(cell.building);
    }
    if (cell.building?.type === 'house' && cell.building.population > 0) {
      totalPopulationSeekingJobs += cell.building.population * config.jobSeekerRatio;
    }
  });
  const totalJobSeekers = Math.floor(totalPopulationSeekingJobs);
  let jobsToFill = Math.min(totalJobsAvailable, totalJobSeekers);
  let totalJobsFilled = 0;
  for (const building of jobProvidingBuildings) {
    if (jobsToFill <= 0) break;
    if (building.powered && !building.onFire) {
      const maxCapacity = config.jobCapacity[building.type];
      const employeesToAssign = Math.min(maxCapacity, jobsToFill);
      building.employees = employeesToAssign;
      totalJobsFilled += employeesToAssign;
      jobsToFill -= employeesToAssign;
    }
  }
  const jobDeficit = totalJobSeekers - totalJobsFilled;
  const jobSurplus = totalJobsFilled - totalJobSeekers;
  let jobSatisfactionMultiplier = 1.0;
  if (jobDeficit > 0) {
    jobSatisfactionMultiplier = Math.max(0.1, 1 - (jobDeficit / Math.max(1, totalJobSeekers)) * 0.7);
    if (jobDeficit > config.jobDeficitComplaintThreshold && year % 5 === 0) {
      logFn("üö® Citizens are complaining about a lack of jobs!");
    }
  } else if (jobSurplus > totalJobSeekers * 0.5 && year % 5 === 0) {
    logFn("üéâ Plenty of job opportunities are attracting new residents!");
    jobSatisfactionMultiplier = 1.1;
  }
  updateCrimeLevels(logFn, year);
  handleRepairs(logFn);
  isRecessionYear = handleDisasters(logFn, population, year);
  distributePower();
  updateRoadWear();
  simulatePollution();
  world.forEach((cell, index) => {
    if (!cell) return;
    if (cell.building?.type === 'house') {
      if (cell.building.powered && !cell.onFire) {
        const pollution = pollutionGrid[index];
        const pollutionPenalty = -Math.floor(pollution / 10);
        const hasRoad = getNeighbors(index, 1).some((n) => world[n]?.base === 'road');
        const hasPark = getNeighbors(index, 5).some((n) => world[n]?.building?.type === 'park' && world[n].building.powered);
        const hasLake = getNeighbors(index, 1).some((n) => world[n]?.base === 'lake');
        const hasTrain = getNeighbors(index, 3).some((n) => world[n]?.base === 'train-track');
        const hasSchool = getNeighbors(index, 15).some((n) => world[n]?.building?.type === 'school' && world[n].building.powered);
        const hasStadium = getNeighbors(index, 20).some((n) => world[n]?.building?.type === 'stadium' && world[n].building.powered);
        const hasPolice = getNeighbors(index, 10).some((n) => world[n]?.building?.type === 'police-station' && world[n].building.powered);
        const hasFire = getNeighbors(index, 10).some((n) => world[n]?.building?.type === 'fire-station' && world[n].building.powered);
        let roadBonus = 0;
        if (hasRoad) {
          roadBonus = 1.0;
        } else {
          if (diffSettings.strictRoads && currentDifficulty === 'hard') roadBonus = -3.0;
        }
        let parkBonus = hasPark ? 1.5 : 0;
        if (diffSettings.strictParks && !hasPark && cell.building.population > 100) {
          parkBonus = -1.0;
        }
        const lakeBonus = hasLake ? 3.5 : 0;
        const trainBonus = hasTrain ? 2.0 : 0;
        const schoolBonus = hasSchool ? 4.0 : 0;
        const stadiumBonus = hasStadium ? 12.0 : 0;
        const policeBonus = hasPolice ? 1.5 : 0;
        const fireBonus = hasFire ? 1.5 : 0;
        const crimePenalty = cell.crimeLevel > 0 && cell.building.population >= 30 ? -5 : 0;
        let taxBonus = 0;
        if (taxRate < 0.6) taxBonus = 5;
        if (taxRate > 0.8) taxBonus = -5;
        const randomFactor = 0.5 + (Math.random() * 0.5);
        let growth = randomFactor + roadBonus + parkBonus + lakeBonus + trainBonus + schoolBonus + stadiumBonus + policeBonus + fireBonus + taxBonus + crimePenalty + pollutionPenalty;
        growth *= diffSettings.growthMultiplier;
        if (pollution > 80) growth = Math.min(growth, -2);
        cell.building.population += growth * jobSatisfactionMultiplier;
        cell.building.population = Math.max(0, Math.min(cell.building.population, 150));
      } else {
        cell.building.population = Math.max(0, cell.building.population - 25);
      }
    }
  });
  const {
    incomeSources,
    expenseSources,
    currentPopulation
  } = getEconomyData(isRecessionYear);
  const yearlyIncome = incomeSources.total;
  const maintenanceCosts = expenseSources.total;
  population = currentPopulation;
  budget += yearlyIncome - maintenanceCosts;
  year++;
  updateIncomeExpense(yearlyIncome, maintenanceCosts);
  return {
    budget,
    population,
    year,
    difficulty
  };
}

function distributePower() {
  world.forEach((cell) => {
    if (cell?.building) {
      cell.building.powered = false;
      if (cell.building.type === 'power-plant' && !cell.building.isPart) {
        cell.building.powerLoad = 0;
      }
    }
  });
  const alreadyPowered = new Set();
  const powerPlants = world
    .map((c, i) => (c?.building?.type === 'power-plant' && !c.building.isPart && !c.building.isDamaged ? i : -1))
    .filter((i) => i !== -1);
  powerPlants.forEach((plantIndex) => {
    const plant = world[plantIndex]?.building;
    if (!plant) return;
    const q = [plantIndex];
    const poweredByThisPlant = new Set();
    const visitedInThisSearch = new Set([plantIndex]);
    if (!alreadyPowered.has(plantIndex)) {
      poweredByThisPlant.add(plantIndex);
      alreadyPowered.add(plantIndex);
    }
    let head = 0;
    while (head < q.length && poweredByThisPlant.size < config.POWER_PLANT_CAPACITY) {
      const currentIndex = q[head++];
      getNeighbors(currentIndex).forEach((neighborIndex) => {
        if (!visitedInThisSearch.has(neighborIndex)) {
          visitedInThisSearch.add(neighborIndex);
          const neighborCell = world[neighborIndex];
          if (neighborCell && (neighborCell.building || neighborCell.hasPowerLine)) {
            q.push(neighborIndex);
            if (!alreadyPowered.has(neighborIndex) && poweredByThisPlant.size < config.POWER_PLANT_CAPACITY) {
              poweredByThisPlant.add(neighborIndex);
              alreadyPowered.add(neighborIndex);
            }
          }
        }
      });
    }
    poweredByThisPlant.forEach((index) => {
      if (world[index]?.building) {
        world[index].building.powered = true;
      }
    });
    plant.powerLoad = poweredByThisPlant.size;
  });
}

function updateRoadWear() {
  world.forEach((cell, i) => {
    if (!cell) return;
    if (cell.base === 'road') {
      let trafficValue = 0;
      getNeighbors(i, 2).forEach((nIndex) => {
        const nCell = world[nIndex];
        if (nCell?.building?.type === 'house' && nCell.building.population) {
          const hasTrainAccess = getNeighbors(nIndex, 3).some(nearbyIndex => world[nearbyIndex]?.base === 'train-track');
          trafficValue += nCell.building.population * (hasTrainAccess ? 0.5 : 1);
        }
        if (nCell?.building?.type === 'industry' && nCell.building.powered) {
          const hasTrainAccess = getNeighbors(nIndex, 3).some(nearbyIndex => world[nearbyIndex]?.base === 'train-track');
          trafficValue += 500 * (hasTrainAccess ? 0.5 : 1);
        }
      });
      cell.hasTraffic = trafficValue > 50;
      if (trafficValue > 1000) cell.roadWear = 3;
      else if (trafficValue > 400) cell.roadWear = 2;
      else if (trafficValue > 150) cell.roadWear = 1;
      else {
        cell.roadWear = Math.max(0, cell.roadWear - 1);
      }
    } else {
      cell.hasTraffic = false;
    }
  });
}

function handleRepairs(logFn) {
  world.forEach((cell) => {
    if (cell?.building?.type === 'power-plant' && cell.building.isDamaged && Math.random() < 0.75) {
      cell.building.isDamaged = false;
      logFn("üõ†Ô∏è A damaged power plant is now fully repaired!");
    }
  });
}

function updateCrimeLevels(logFn, year) {
  if (gameState.population < 5000) {
    world.forEach((cell) => {
      if (cell) cell.crimeLevel = 0;
    });
    return;
  }
  const quadrantCrime = {
    nw: 0,
    ne: 0,
    sw: 0,
    se: 0
  };
  const mid = config.gridSize / 2;
  world.forEach((cell, index) => {
    if (!cell) return;
    cell.crimeLevel = 0;
    if (cell.building?.type === 'house' && cell.building.population >= 30) {
      const policeNearby = getNeighbors(index, 30).some((n) => world[n]?.building?.type === 'police-station' && world[n].building.powered);
      if (!policeNearby) {
        cell.crimeLevel = 1;
        const x = index % config.gridSize;
        const y = Math.floor(index / config.gridSize);
        if (y < mid && x < mid) quadrantCrime.nw++;
        else if (y < mid && x >= mid) quadrantCrime.ne++;
        else if (y >= mid && x < mid) quadrantCrime.sw++;
        else quadrantCrime.se++;
      }
    }
  });
  let maxCrimeCount = 0;
  let maxCrimeQuadrantKey = '';
  for (const key in quadrantCrime) {
    if (quadrantCrime[key] > maxCrimeCount) {
      maxCrimeCount = quadrantCrime[key];
      maxCrimeQuadrantKey = key;
    }
  }
  if (maxCrimeCount > 4) {
    const quadrantNames = {
      nw: "northwestern",
      ne: "northeastern",
      sw: "southwestern",
      se: "southeastern"
    };
    logFn(`üö® Citizens are complaining about crime in the ${quadrantNames[maxCrimeQuadrantKey] || maxCrimeQuadrantKey} part of town!`);
  }
}

function handleDisasters(logFn, population, year) {
  let isRecession = false;
  const firesToSpread = [];
  world.forEach((cell, index) => {
    if (!cell) return;
    if (cell.onFire) {
      const fireStationNearby = getNeighbors(index, 20).some(
        (n) => world[n]?.building?.type === 'fire-station' && world[n].building.powered
      );
      if (fireStationNearby && Math.random() < 0.8) {
        cell.onFire = false;
        logFn("üöí The fire department has extinguished a fire!");
      } else if (Math.random() < 0.1) {
        const buildingType = cell.building?.type;
        logFn(`üî• ${config.buildingDisplayNames[buildingType] || 'A building'} was lost in the blaze!`);
        if (buildingType) {
          const originalCost = config.costs[buildingType] || 0;
          const insurancePayout = Math.floor(originalCost * 0.6);
          gameState.budget += insurancePayout;
          if (insurancePayout > 0) {
            logFn(`üí∞ Received an insurance payout of $${insurancePayout.toLocaleString()} for the destroyed ${config.buildingDisplayNames[buildingType]}.`);
          }
          if (config.largeBuildings.includes(buildingType)) {
            clear2x2Building(cell.building.originIndex);
          } else {
            if (buildingType === 'industry') {
              industrialZones = industrialZones.filter(i => i !== index);
            }
            cell.building = null;
          }
        }
        cell.onFire = false;
      } else {
        getNeighbors(index, 1).forEach((nIndex) => {
          const neighborCell = world[nIndex];
          if (neighborCell?.building && !neighborCell.onFire && Math.random() < 0.2) {
            firesToSpread.push(nIndex);
          }
        });
      }
    }
  });
  firesToSpread.forEach(index => {
    if (world[index]) world[index].onFire = true;
  });
  const disasterChance = 0.01 + (population / config.WIN_CONDITION_POPULATION) * 0.035;
  if (Math.random() < disasterChance) {
    const possibleDisasters = ['recession'];
    if (world.some((cell) => cell?.building)) possibleDisasters.push('fire', 'kingkong');
    if (world.some((c) => c?.building?.type === 'power-plant' && !c.building.isDamaged)) possibleDisasters.push('thunderstorm');
    if (possibleDisasters.length > 0) {
      const chosenDisaster = possibleDisasters[Math.floor(Math.random() * possibleDisasters.length)];
      if (chosenDisaster === 'fire') {
        const buildings = world.map((c, i) => (c?.building ? i : -1)).filter((i) => i !== -1);
        if (buildings.length > 0) {
          const fireIndex = buildings[Math.floor(Math.random() * buildings.length)];
          if (world[fireIndex]) {
            world[fireIndex].onFire = true;
            scrollToIndex(fireIndex);
          }
          logFn("üî• A fire has broken out!");
        }
      } else if (chosenDisaster === 'recession') {
        isRecession = true;
        logFn("üìâ An economic recession has hit the city!");
      } else if (chosenDisaster === 'thunderstorm') {
        const powerPlants = world
          .map((c, i) => (c?.building?.type === 'power-plant' && !c.building.isDamaged ? i : -1))
          .filter((i) => i !== -1);
        if (powerPlants.length > 0) {
          const targetPlantIndex = powerPlants[Math.floor(Math.random() * powerPlants.length)];
          if (world[targetPlantIndex]?.building) {
            world[targetPlantIndex].building.isDamaged = true;
            scrollToIndex(targetPlantIndex);
          }
          logFn("‚õàÔ∏è A thunderstorm has damaged a power plant!");
          if (audioManager) audioManager.playThunderEffect();
        }
      } else if (chosenDisaster === 'kingkong') {
        logFn("ü¶ç King Kong is rampaging through the city!");
        if (typeof kingKongRampage === 'function') kingKongRampage();
      }
    }
  }
  return isRecession;
}

function kingKongRampage() {
  if (gameState.isDisasterAnimating) return;
  const buildingIndices = [];
  world.forEach((cell, index) => {
    if (cell && cell.building && !cell.building.isPart) {
      buildingIndices.push(index);
    }
  });
  if (buildingIndices.length === 0) return;
  gameState.isDisasterAnimating = true;
  const startIndex = buildingIndices[Math.floor(Math.random() * buildingIndices.length)];
  let currentIdx = startIndex;
  scrollToIndex(startIndex);
  if (audioManager) audioManager.playMonsterRoar();
  const steps = 15;
  let completedSteps = 0;
  function doStep(stepNum) {
    gameState.kingKongLocation = currentIdx;
    const x = currentIdx % config.gridSize;
    const y = Math.floor(currentIdx / config.gridSize);
    const directions = [
      [0, 1],
      [0, -1],
      [1, 0],
      [-1, 0]
    ];
    const [dx, dy] = directions[Math.floor(Math.random() * directions.length)];
    const nextX = x + dx;
    const nextY = y + dy;
    if (nextX >= 0 && nextX < config.gridSize && nextY >= 0 && nextY < config.gridSize) {
      currentIdx = nextY * config.gridSize + nextX;
    }
    const index = currentIdx;
    const cell = world[index];
    if (cell) {
      if (cell.building) {
        const buildingType = cell.building.type;
        if (config.largeBuildings.includes(buildingType)) {
          if (cell.building.originIndex !== undefined) {
            clear2x2Building(cell.building.originIndex);
          } else {
            cell.building = null;
          }
        } else {
          if (buildingType === 'industry') {
            industrialZones = industrialZones.filter(i => i !== index);
          }
          cell.building = null;
        }
        audioManager.playBuildingSound();
      }
      world[index] = {
        base: 'grass',
        building: null,
        hasPowerLine: false,
        onFire: false,
        roadWear: 0,
        crimeLevel: 0,
        hasTraffic: false
      };
    }
    completedSteps++;
    if (completedSteps >= steps) {
      setTimeout(() => {
        gameState.isDisasterAnimating = false;
        gameState.kingKongLocation = null;
        distributePower();
        updateMinimap();
        industrialZones = [];
        world.forEach((cell, i) => {
          if (cell?.building?.type === 'industry') {
            industrialZones.push(i);
          }
        });
      }, 500);
    }
  }
  for (let i = 0; i < steps; i++) {
    setTimeout(() => doStep(i), i * 300);
  }
}

function getCellIndexFromEvent(e) {
  if (!canvas || !mapContainer) return -1;
  const rect = canvas.getBoundingClientRect();
  const canvasX = e.clientX - rect.left;
  const canvasY = e.clientY - rect.top;
  const worldX = canvasX + mapContainer.scrollLeft;
  const worldY = canvasY + mapContainer.scrollTop;
  const gridX = Math.floor(worldX / config.cellSize);
  const gridY = Math.floor(worldY / config.cellSize);
  if (gridX < 0 || gridX >= config.gridSize || gridY < 0 || gridY >= config.gridSize) {
    return -1;
  }
  const index = gridY * config.gridSize + gridX;
  return (index >= 0 && index < world.length) ? index : -1;
}

function place2x2Building(index, type) {
  const indices = [index, index + 1, index + config.gridSize, index + config.gridSize + 1];
  if (indices.every(i => i >= 0 && i < world.length)) {
    const buildingData = {
      type: type,
      powered: false,
      originIndex: index
    };
    if (config.jobCapacity[type]) {
      buildingData.employees = 0;
    }
    if (type === 'power-plant') {
      buildingData.powerLoad = 0;
      buildingData.isDamaged = false;
    }
    indices.forEach((i, part) => {
      if (world[i]) {
        world[i].building = {
          ...buildingData,
          isPart: part > 0
        };
        world[i].base = 'grass';
        world[i].hasPowerLine = false;
      }
    });
    showTickerMessage(`Built ${config.buildingDisplayNames[type]}.`);
  } else {
    console.error("Attempted to place 2x2 building out of bounds", index);
  }
}

let saveBtn, newGameBtn;

function initGameManagerElements() {
  saveBtn = document.getElementById('save-btn');
  newGameBtn = document.getElementById('new-game-btn');
}

function exportGame() {
  try {
    const pollutionData = Array.from(pollutionGrid);
    const dataToSave = {
      world: world,
      pollutionGrid: pollutionData,
      budget: gameState.budget,
      population: gameState.population,
      year: gameState.year,
      isGameOver: gameState.isGameOver,
      hasWon: gameState.hasWon,
      gameLog: gameState.gameLog,
      taxRate: gameState.taxRate,
      difficulty: gameState.difficulty
    };
    const json = JSON.stringify(dataToSave);
    const blob = new Blob([json], {
      type: "application/json"
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `City_Year${gameState.year}_Pop${gameState.population}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    showTickerMessage("üì§ City exported successfully!");
  } catch (e) {
    console.error(e);
    alert("Failed to export game.");
  }
}

function importGame() {
  document.getElementById('import-input').click();
}

function handleFileSelect(e) {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function(event) {
    try {
      const data = JSON.parse(event.target.result);
      if (!data.world || !data.budget) {
        alert("Invalid save file!");
        return;
      }
      if (confirm("Warning: Importing a city will overwrite your current city. Continue?")) {
        world = data.world;
        if (data.pollutionGrid) pollutionGrid = new Uint8Array(data.pollutionGrid);
        gameState.budget = data.budget;
        gameState.population = data.population;
        gameState.year = data.year;
        gameState.isGameOver = data.isGameOver;
        gameState.hasWon = data.hasWon || false;
        gameState.gameLog = data.gameLog || [];
        gameState.taxRate = data.taxRate || 0.7;
        gameState.difficulty = data.difficulty || 'easy';
        const difficultySelect = document.getElementById('difficulty-select');
        if (difficultySelect) {
          difficultySelect.value = gameState.difficulty;
        }
        industrialZones = [];
        world.forEach((cell, index) => {
          if (cell.building?.type === 'industry') {
            industrialZones.push(index);
          }
        });
        distributePower();
        updateTrainPaths();
        updateStatsPanel(gameState);
        updateMinimap();
        updateIncomeExpense(0, 0);
        showTickerMessage("üì• City imported successfully!");
      }
    } catch (err) {
      console.error(err);
      alert("Error reading save file.");
    }
    e.target.value = '';
  };
  reader.readAsText(file);
}

function init() {
  initCanvas();
  initUIElements();
  initGameManagerElements();
  audioManager = new AudioManager();
  const savedData = loadWorld();
  if (savedData) {
    gameState.budget = savedData.budget ?? 100000;
    gameState.population = savedData.population ?? 0;
    gameState.year = savedData.year ?? 2025;
    gameState.isGameOver = savedData.isGameOver ?? false;
    gameState.gameLog = savedData.gameLog ?? [];
    gameState.taxRate = savedData.taxRate ?? 0.7;
    gameState.difficulty = savedData.difficulty || 'easy';
    document.querySelectorAll('.tax-btn').forEach((btn) => {
      btn.classList.remove('active');
      if (parseFloat(btn.dataset.rate) === gameState.taxRate) {
        btn.classList.add('active');
      }
    });
  } else {
    gameState.budget = 100000;
    gameState.population = 0;
    gameState.year = 2025;
    gameState.isGameOver = false;
    gameState.gameLog = [];
    gameState.taxRate = 0.7;
    gameState.difficulty = 'easy';
    document.querySelectorAll('.tax-btn').forEach(btn => btn.classList.remove('active'));
    const defaultTaxBtn = document.querySelector('.tax-btn[data-rate="0.7"]');
    if (defaultTaxBtn) defaultTaxBtn.classList.add('active');
  }
  const difficultySelect = document.getElementById('difficulty-select');
  if (difficultySelect) {
    difficultySelect.value = gameState.difficulty;
  }
  setupEventListeners();
  createClouds();
  distributePower();
  updateTrainPaths();
  updateStatsPanel(gameState);
  updateMinimap();
  render();
  audioManager.playWindAmbiance();
  if (gameState.gameInterval) clearInterval(gameState.gameInterval);
  if (!gameState.isGameOver) {
    gameState.gameInterval = setInterval(gameTick, 10000);
  } else {
    handleGameOver(`Loaded game was already over in year ${gameState.year}.`);
  }
  showHelp();
}

function gameTick() {
  if (gameState.isGameOver) {
    clearInterval(gameState.gameInterval);
    return;
  }
  const newStateChanges = simulateYear(gameState, logEvent);
  Object.assign(gameState, newStateChanges);
  updateStatsPanel(gameState);
  updateFireLayer();
  updateMinimap();
  if (gameState.population >= config.WIN_CONDITION_POPULATION && !gameState.hasWon && !gameState.isGameOver) {
    winGame();
  }
  if (gameState.budget < 0 && !gameState.isGameOver) {
    loseGame();
  }
}

function logEvent(message) {
  const entry = `Year ${gameState.year}: ${message}`;
  gameState.gameLog.unshift(entry);
  if (gameState.gameLog.length > config.MAX_LOG_ENTRIES) {
    gameState.gameLog.pop();
  }
  showTickerMessage(message);
}

function saveGame() {
  if (gameState.isGameOver) {
    showTickerMessage("Cannot save a completed game.");
    return;
  }
  try {
    const pollutionData = Array.from(pollutionGrid);
    const dataToSave = {
      world: world,
      pollutionGrid: pollutionData,
      budget: gameState.budget,
      population: gameState.population,
      year: gameState.year,
      isGameOver: gameState.isGameOver,
      hasWon: gameState.hasWon,
      gameLog: gameState.gameLog,
      taxRate: gameState.taxRate,
      difficulty: gameState.difficulty
    };
    localStorage.setItem('cityBuilderSave', JSON.stringify(dataToSave));
    showTickerMessage("üíæ Game saved!");
  } catch (e) {
    console.error('Error saving game:', e);
    if (e.name === 'QuotaExceededError') {
      alert('Could not save game: Storage quota exceeded. Try clearing some browser data.');
    } else {
      alert('Could not save the game. Your browser might be out of storage space or in private mode.');
    }
  }
}

function newGame(e) {
  if (e) e.preventDefault();
  if (confirm("Are you sure? This will delete your current city and start a new game.")) {
    localStorage.removeItem('cityBuilderSave');
    gameState.budget = 100000;
    gameState.population = 0;
    gameState.year = 2025;
    gameState.isGameOver = false;
    gameState.hasWon = false;
    gameState.gameLog = [];
    gameState.isDisasterAnimating = false;
    gameState.taxRate = 0.7;
    gameState.currentTool = '';
    document.querySelectorAll('.tax-btn').forEach((b) => b.classList.remove('active'));
    const defaultTaxBtn = document.querySelector('.tax-btn[data-rate="0.7"]');
    if (defaultTaxBtn) defaultTaxBtn.classList.add('active');
    if (saveBtn) saveBtn.disabled = false;
    if (newGameBtn) {
      newGameBtn.textContent = "‚ú® New Game";
      newGameBtn.style.backgroundColor = '';
    }
    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
    if (canvas) canvas.className = '';
    initEmptyWorld();
    distributePower();
    updateTrainPaths();
    updateStatsPanel(gameState);
    updateMinimap();
    updateIncomeExpense(0, 0);
    if (gameState.gameInterval) clearInterval(gameState.gameInterval);
    gameState.gameInterval = setInterval(gameTick, 10000);
    showTickerMessage("A new city has been founded!");
    hasScrolledToCenter = false;
    if (viewport.width > 0 && viewport.height > 0) {
      const totalMapWidth = config.gridSize * config.cellSize;
      const totalMapHeight = config.gridSize * config.cellSize;
      if (mapContainer) {
        mapContainer.scrollLeft = (totalMapWidth - viewport.width) / 2;
        mapContainer.scrollTop = (totalMapHeight - viewport.height) / 2;
        hasScrolledToCenter = true;
        updateMinimapViewport();
      }
    }
  }
}

function winGame() {
  if (gameState.hasWon) return;
  gameState.hasWon = true;
  logEvent(`üèÜ Congratulations! You reached ${config.WIN_CONDITION_POPULATION.toLocaleString()} residents in year ${gameState.year}!`);
  const fireworks = document.getElementById('fireworks-container');
  if (fireworks) {
    const textContainer = fireworks.querySelector('.congrats-text');
    if (textContainer) {
      textContainer.innerHTML = `
<h1>üèÜ Congratulations! üèÜ</h1>
<p>You've built an amazing city!</p>
<p style="font-size: 16px; margin-top: 20px; color: #aaa;">
Reminder: If you want to keep this city, remember to <strong>Export</strong> your save file before starting a new game.
</p>
<p style="font-size: 14px; margin-top: 10px; color: #888;">(Click to continue playing)</p>
`;
    }
    fireworks.classList.add('active');
    fireworks.addEventListener('click', () => {
      fireworks.classList.remove('active');
    }, {
      once: true
    });
  }
}

function loseGame() {
  if (gameState.isGameOver) return;
  gameState.isGameOver = true;
  logEvent(`BANKRUPTCY: The city went bankrupt in year ${gameState.year}.`);
  clearInterval(gameState.gameInterval);
  handleGameOver(`GAME OVER\n\nYour city went bankrupt in year ${gameState.year}!`);
}

function handleGameOver(message) {
  if (gameState.gameInterval) clearInterval(gameState.gameInterval);
  setTimeout(() => {
    if (saveBtn) saveBtn.disabled = true;
    if (newGameBtn) {
      newGameBtn.textContent = "‚ú® Restart";
      newGameBtn.style.backgroundColor = '#4CAF50';
    }
  }, 100);
}

function onCanvasClick(e) {
  const index = getCellIndexFromEvent(e);
  if (index === -1) return;
  handleCellClick(index);
}

function handleCellClick(index) {
  if (index === -1 || !world[index]) return;
  const {
    currentTool,
    isDisasterAnimating,
    isGameOver,
    budget,
    difficulty
  } = gameState;
  if (isDisasterAnimating || !currentTool || isGameOver || budget < 0) return;
  const diffSetting = config.difficultySettings[difficulty || 'easy'];
  const costMultiplier = diffSetting.constructionCostMultiplier || 1.0;
  let baseCost = config.costs[currentTool] || 0;
  const finalCost = Math.floor(baseCost * costMultiplier);
  if (budget < finalCost) {
    showTickerMessage(`Not enough money! Need $${finalCost.toLocaleString()}`);
    return;
  }
  let cell = world[index];
  if (cell.base === 'lake' && !['power-line', 'bulldoze'].includes(currentTool)) return;
  let actionTaken = false;
  if (config.largeBuildings.includes(currentTool)) {
    if (check2x2Area(index)) {
      gameState.budget -= finalCost;
      place2x2Building(index, currentTool);
      actionTaken = true;
    } else {
      showTickerMessage("Not enough space for this 2x2 building!");
    }
  } else if (currentTool === 'road') {
    if (cell.base === 'train-track') {
      gameState.budget -= finalCost;
      cell.base = 'rail-crossing';
      cell.roadWear = 0;
      cell.hasTraffic = false;
      actionTaken = true;
    } else if (cell.base === 'grass' && !cell.building) {
      gameState.budget -= finalCost;
      cell.base = 'road';
      cell.roadWear = 0;
      cell.hasTraffic = false;
      actionTaken = true;
    }
  } else if (currentTool === 'train-track') {
    if (cell.base === 'road') {
      gameState.budget -= finalCost;
      cell.base = 'rail-crossing';
      actionTaken = true;
    } else if (cell.base === 'grass' && !cell.building) {
      gameState.budget -= finalCost;
      cell.base = 'train-track';
      actionTaken = true;
    }
  } else if (currentTool === 'power-line') {
    if (!cell.hasPowerLine && !cell.building && (cell.base === 'grass' || cell.base === 'road' || cell.base === 'lake' || cell.base === 'train-track' || cell.base === 'rail-crossing')) {
      gameState.budget -= finalCost;
      cell.hasPowerLine = true;
      actionTaken = true;
    }
  } else if (currentTool === 'bulldoze') {
    if (cell.building || cell.hasPowerLine || cell.base === 'road' || cell.base === 'train-track' || cell.base === 'rail-crossing') {
      gameState.budget -= finalCost;
      if (cell.building) {
        const buildingType = cell.building.type;
        if (config.largeBuildings.includes(buildingType)) {
          if (cell.building.originIndex !== undefined) {
            clear2x2Building(cell.building.originIndex);
          } else {
            cell.building = null;
          }
        } else {
          if (buildingType === 'industry') {
            industrialZones = industrialZones.filter(i => i !== index);
          }
          cell.building = null;
        }
        if (cell.onFire) cell.onFire = false;
      } else if (cell.hasPowerLine) {
        cell.hasPowerLine = false;
      } else if (cell.base === 'road' || cell.base === 'train-track' || cell.base === 'rail-crossing') {
        cell.base = 'grass';
        cell.roadWear = 0;
        cell.hasTraffic = false;
      }
      actionTaken = true;
    }
  } else {
    if (!cell.building && cell.base === 'grass' && !cell.hasPowerLine) {
      gameState.budget -= finalCost;
      let buildingData = {
        type: currentTool,
        population: 0,
        powered: false
      };
      if (config.jobCapacity[currentTool]) {
        buildingData.employees = 0;
      }
      if (currentTool === 'park') buildingData.hasFountain = Math.random() < 0.1;
      if (currentTool === 'power-plant') {
        buildingData.powerLoad = 0;
        buildingData.isDamaged = false;
      }
      cell.building = buildingData;
      actionTaken = true;
      if (currentTool === 'industry') {
        industrialZones.push(index);
      }
      showTickerMessage(`Built ${config.buildingDisplayNames[currentTool]} (-$${finalCost})`);
    }
  }
  if (actionTaken) {
    if (currentTool === 'train-track' || currentTool === 'bulldoze' || currentTool === 'road') {
      updateTrainPaths();
    }
    audioManager.playBuildingSound();
    if (currentTool === 'police-station' || currentTool === 'fire-station') {
      audioManager.playSirenEffect();
    }
    distributePower();
    updateStatsPanel(gameState);
    updateMinimap();
  }
}

function onCanvasMouseOver(e) {
  const index = getCellIndexFromEvent(e);
  if (index === -1) {
    hideTooltip();
    return;
  }
  showTooltip(index, e);
}

function onCanvasMouseOut() {
  hideTooltip();
}

function handleMinimapNavigation(e) {
  const minimapCanvasEl = document.getElementById('minimap-canvas');
  if (!minimapCanvasEl || !gridContainer || !mapContainer) return;
  const rect = minimapCanvasEl.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;
  if (clickX < 0 || clickX > rect.width || clickY < 0 || clickY > rect.height) {
    return;
  }
  const xPercent = clickX / rect.width;
  const yPercent = clickY / rect.height;
  const totalMapWidth = gridContainer.scrollWidth;
  const totalMapHeight = gridContainer.scrollHeight;
  if (totalMapWidth === 0 || totalMapHeight === 0 || mapContainer.clientWidth === 0 || mapContainer.clientHeight === 0) return;
  const targetScrollLeft = (xPercent * totalMapWidth) - (mapContainer.clientWidth / 2);
  const targetScrollTop = (yPercent * totalMapHeight) - (mapContainer.clientHeight / 2);
  mapContainer.scrollLeft = targetScrollLeft;
  mapContainer.scrollTop = targetScrollTop;
  updateMinimapViewport();
}

function ensureAudioContextResumed() {
  if (audioManager && audioManager.audioCtx && audioManager.audioCtx.state === 'suspended') {
    audioManager.audioCtx.resume().catch(e => console.error("Error resuming AudioContext:", e));
  }
}

function setupEventListeners() {
  if (canvas) {
    canvas.addEventListener('click', (e) => {
      ensureAudioContextResumed();
      onCanvasClick(e);
    });
    canvas.addEventListener('mousemove', onCanvasMouseOver);
    canvas.addEventListener('mouseout', onCanvasMouseOut);
  }
  if (mapContainer) {
    mapContainer.addEventListener('scroll', updateMinimapViewport);
  }
  const minimapWrapperEl = document.getElementById('minimap-wrapper');
  const nightModeBtn = document.getElementById('night-mode-btn');
  const cityLogBtn = document.getElementById('city-log-btn');
  const howToPlayBtn = document.getElementById('how-to-play-btn');
  const economyBtn = document.getElementById('economy-btn');
  const economyModalCloseBtn = document.getElementById('economy-modal-close');
  const muteSoundBtn = document.getElementById('mute-sound-btn');
  const difficultySelect = document.getElementById('difficulty-select');
  if (difficultySelect) {
    difficultySelect.addEventListener('change', (e) => {
      gameState.difficulty = e.target.value;
      showTickerMessage(`Difficulty changed to: ${e.target.options[e.target.selectedIndex].text}`);
    });
  }
  if (minimapWrapperEl) {
    minimapWrapperEl.addEventListener('mousedown', (e) => {
      ensureAudioContextResumed();
      gameState.isDraggingMinimap = true;
      handleMinimapNavigation(e);
      e.preventDefault();
    });
  }
  document.addEventListener('mousemove', (e) => {
    if (gameState.isDraggingMinimap) {
      handleMinimapNavigation(e);
    }
  });
  document.addEventListener('mouseup', () => {
    if (gameState.isDraggingMinimap) {
      gameState.isDraggingMinimap = false;
    }
  });
  document.querySelectorAll('.tool-btn').forEach((btn) => {
    btn.addEventListener('click', (e) => {
      ensureAudioContextResumed();
      document.querySelectorAll('.tool-btn').forEach((b) => b.classList.remove('active'));
      e.currentTarget.classList.add('active');
      gameState.currentTool = btn.dataset.tool;
      if (canvas) {
        canvas.className = btn.dataset.tool === 'bulldoze' ? 'bulldoze-cursor' : 'build-cursor';
      }
    });
  });
  document.querySelectorAll('.tax-btn').forEach((btn) => {
    btn.addEventListener('click', (e) => {
      ensureAudioContextResumed();
      gameState.taxRate = parseFloat(e.currentTarget.dataset.rate);
      document.querySelectorAll('.tax-btn').forEach((b) => b.classList.remove('active'));
      e.currentTarget.classList.add('active');
      showTickerMessage(`Taxes set to ${e.currentTarget.textContent.trim()}.`);
    });
  });
  if (nightModeBtn) {
    nightModeBtn.addEventListener('click', () => {
      ensureAudioContextResumed();
      if (gameLayout) gameLayout.classList.toggle('night-mode');
    });
  }
  if (saveBtn) saveBtn.addEventListener('click', () => {
    ensureAudioContextResumed();
    saveGame();
  });
  if (newGameBtn) newGameBtn.addEventListener('click', (e) => {
    ensureAudioContextResumed();
    newGame(e);
  });
  if (cityLogBtn) cityLogBtn.addEventListener('click', () => {
    ensureAudioContextResumed();
    showLog(gameState.gameLog);
  });
  if (howToPlayBtn) howToPlayBtn.addEventListener('click', () => {
    ensureAudioContextResumed();
    showHelp();
  });
  if (economyBtn) economyBtn.addEventListener('click', () => {
    ensureAudioContextResumed();
    showEconomyWindow();
  });
  if (economyModalCloseBtn) {
    economyModalCloseBtn.addEventListener('click', () => {
      const modal = document.getElementById('economy-modal');
      if (modal) modal.style.display = 'none';
      audioManager.resume().catch(e => console.error("Error resuming AudioContext on economy close:", e));
    });
  }
  document.querySelectorAll('.modal').forEach(modal => {
    const closeBtn = modal.querySelector('.modal-close');
    if (closeBtn) {
      closeBtn.onclick = () => {
        modal.style.display = 'none';
        audioManager.resume().catch(e => console.error("Error resuming AudioContext on modal close:", e));
      };
    }
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        modal.style.display = 'none';
        audioManager.resume().catch(e => console.error("Error resuming AudioContext on modal overlay close:", e));
      }
    });
  });
  const exportBtn = document.getElementById('export-btn');
  const importBtn = document.getElementById('import-btn');
  const importInput = document.getElementById('import-input');
  if (exportBtn) exportBtn.addEventListener('click', () => {
    ensureAudioContextResumed();
    exportGame();
  });
  if (importBtn) importBtn.addEventListener('click', () => {
    ensureAudioContextResumed();
    importGame();
  });
  if (importInput) importInput.addEventListener('change', handleFileSelect);
  if (muteSoundBtn) {
    muteSoundBtn.addEventListener('click', () => {
      audioManager.toggleMute();
      muteSoundBtn.textContent = audioManager.isMuted ? 'üîá' : 'üîä';
      muteSoundBtn.title = audioManager.isMuted ? 'Unmute Sound' : 'Mute Sound';
      if (audioManager.isMuted) {
        muteSoundBtn.classList.add('muted');
      } else {
        muteSoundBtn.classList.remove('muted');
      }
    });
    muteSoundBtn.textContent = audioManager.isMuted ? 'üîá' : 'üîä';
    muteSoundBtn.title = audioManager.isMuted ? 'Unmute Sound' : 'Mute Sound';
    if (audioManager.isMuted) {
      muteSoundBtn.classList.add('muted');
    } else {
      muteSoundBtn.classList.remove('muted');
    }
  }
}
document.addEventListener('DOMContentLoaded', init);
</script>
<script>
(function() {
  const style = document.createElement('style');
  style.innerHTML = `
html, body, #map-container {
overscroll-behavior-x: none !important;
overscroll-behavior-y: none !important;
touch-action: pan-x pan-y; /* Hjelper for touch-skjermer */
}
`;
  document.head.appendChild(style);
  const mapContainer = document.getElementById('map-container');
  if (mapContainer) {
    mapContainer.addEventListener('wheel', function(e) {
      if (Math.abs(e.deltaX) > Math.abs(e.deltaY)) {
        if (mapContainer.scrollLeft <= 0 && e.deltaX < 0) {
          e.preventDefault();
        } else if (mapContainer.scrollLeft + mapContainer.clientWidth >= mapContainer.scrollWidth && e.deltaX > 0) {
          e.preventDefault();
        }
      }
    }, {
      passive: false
    });
  }
})();
</script>
<script>
(function() {
  const css = `
#landscape-warning-overlay {
display: none;
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: #000;
color: #0f0;
z-index: 999999;
flex-direction: column;
justify-content: center;
align-items: center;
text-align: center;
font-family: Consolas, 'Courier New', monospace;
padding: 20px;
box-sizing: border-box;
}

/* Vis kun p√• skjermer som er h√∏yere enn de er brede (Portrett) */
@media screen and (orientation: portrait) {
#landscape-warning-overlay {
display: flex !important;
}
}

#landscape-warning-overlay svg {
width: 80px;
height: 80px;
fill: #0f0;
margin-bottom: 20px;
animation: rotate-phone-anim 2s infinite ease-in-out;
}

#landscape-warning-overlay p {
font-size: 1.2em;
text-transform: uppercase;
letter-spacing: 2px;
margin: 0;
text-shadow: 0 0 5px #0f0;
}

@keyframes rotate-phone-anim {
0%, 10% { transform: rotate(0deg); }
40%, 60% { transform: rotate(-90deg); }
90%, 100% { transform: rotate(-90deg); }
}
`;
  const style = document.createElement('style');
  style.appendChild(document.createTextNode(css));
  document.head.appendChild(style);
  const overlay = document.createElement('div');
  overlay.id = 'landscape-warning-overlay';
  overlay.innerHTML = `
<svg viewBox="0 0 24 24">
<path d="M17,1.01L7,1C5.9,1 5,1.9 5,3v18c0,1.1 0.9,2 2,2h10c1.1,0 2,-0.9 2,-2V3C19,1.9 18.1,1.01 17,1.01z M17,21H7l0,-1h10V21z M17,18H7V6h10V18z M7,4V3h10v1H7z"/>
</svg>
<p>Please Rotate Device</p>
`;
  document.body.appendChild(overlay);
})();
</script>
</body>
</html>